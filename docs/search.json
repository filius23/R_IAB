[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R am IAB",
    "section": "",
    "text": "Willkommen\nEine Einführung in R für Mitarbeitende am IAB.\n\n\n\n\n\n\n\n\n\nKursinformationen\n\n   12.06., 13.06., 16.06. & 19.06.2023\n   8:30 – 15:30 Uhr\n   E09"
  },
  {
    "objectID": "01_intro.html",
    "href": "01_intro.html",
    "title": "1  Einstieg in R",
    "section": "",
    "text": "Bei R handelt es sich um ein vollständig kostenloses Programm, das Sie unter CRAN herunterladen können. Ebenfalls kostenlos ist die Erweiterung RStudio, die Sie unter hier herunterladen können. RStudio erweitert R um eine deutlich informativere und ansprechendere Oberfläche, Hilfe und Auto-Vervollständigung beim Schreiben von Syntax und insgesamt eine verbesserte Nutzeroberfläche. Jedoch ist RStudio eine Erweiterung von R, sodass Sie beide Programme benötigen.\n\n\n\n\n\n\nNote\n\n\n\nInstallieren Sie zuerst R und dann RStudio, dann erkennt RStudio die installierte R-Version und die beiden Programme verbinden sich in der Regel automatisch. R ist dabei sozusagen der Motor, RStudio unser Cockpit. Wir könnten direkt mit R arbeiten, aber mit RStudio haben wir eine komfortablere Option und einen besseren Überblick.\n\n\n\n\n\n\n \n\n\nFigure 1.1: R und RStudio"
  },
  {
    "objectID": "01_intro.html#rstudio-einrichten",
    "href": "01_intro.html#rstudio-einrichten",
    "title": "1  Einstieg in R",
    "section": "1.2 RStudio einrichten",
    "text": "1.2 RStudio einrichten\nÖffnen Sie nach erfolgreicher Installation die Anwendung RStudio  und Sie sollten folgende Ansicht vor sich sehen:\n\n\n\n\nUm Probleme bei der künftigen Arbeit mit R zu vermeiden, deaktivieren Sie bitte das automatische Speichern und Laden des Workspace. Rufen Sie dazu das entsprechende Menü unter dem Reiter “Tools -> Global options” auf und deaktivieren Sie bitte “Restore .RData into workspace at startup” und setzen Sie “Save workspace to .RData on exit:” auf Never. RStudio speichert ansonsten alle geladenen Objekte wenn Sie die Sitzung beenden und lädt diese automatisch wenn Sie das Programm das nächste Mal öffnen. Dies führt erfahrungsgemäß zu Problemen.\n\n\n\n\nBestätigen Sie die Einstellungen mit “Apply” und schließen Sie das Fenster mit “OK”."
  },
  {
    "objectID": "01_intro.html#erste-schritte-in-r",
    "href": "01_intro.html#erste-schritte-in-r",
    "title": "1  Einstieg in R",
    "section": "1.3 Erste Schritte in R",
    "text": "1.3 Erste Schritte in R\nNach diesen grundlegenden Einstellungen können wir uns an die ersten Schritte in R machen. Öffnen Sie dazu zunächst ein Script, indem Sie auf das weiße Symbol links oben klicken oder drücken Sie gleichzeitig STRG/Command + Shift + N .\n\n\n\n\nEs öffnet sich ein viertes Fenster, sodass Sie nun folgende Ansicht vor sich haben sollten:\n\n\n\n\nDieser Scripteditor ist der Ort, an dem wir Befehle erstellen und anschließend durchführen werden. Der Scripteditor dient dabei als Sammlung aller durchzuführenden Befehle. Wir können diese Sammlungen speichern, um sie später wieder aufzurufen und vor allem können wir so Befehlssammlungen mit anderen teilen oder Skripte von anderen für uns selbst nutzen. Wir entwerfen also zunächst im Scripteditor eine Rechnung:\n\n\n\n\nUm diese nun auszuführen, klicken wir in die auszuführende Zeile, sodass der Cursor in dieser Zeile ist und drücken gleichzeitig STRG und Enter (Mac-User Command und Enter):\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1.2: Shortcuts für Berechnungen\n\n\nR gibt die Ergebnisse unten in der Console aus:\n\n\n\n\nDas funktioniert auch für mehrere Rechnungen auf einmal indem wir mehrere Zeilen markieren und dann wieder STRG und Enter (Mac-User Command und Enter) drücken:\n\n\n\n\nEingaben aus dem Script-Editor und Ergebnisse aus der Konsole werden in Zukunft so dargestellt:\n\n2+5\n\n[1] 7\n\n3-4\n\n[1] -1\n\n5*6\n\n[1] 30\n\n7/8\n\n[1] 0.875\n\n\nR beherrscht natürlich auch längere Berechnungen, zum Beispiel wird auch Punkt vor Strich beachtet:\n\n2+3*2\n\n[1] 8\n\n(2+3)*2\n\n[1] 10\n\n\nAuch weitere Operationen sind möglich:\n\n4^2 ## 4²\nsqrt(4) ## Wurzel \nexp(1) ## Exponentialfunktion (Eulersche Zahl)\nlog(5) ## Natürlicher Logarithmus\nlog(exp(5)) ## log und exp heben sich gegenseitig auf\n\nZahlenreihen können wir mit seq() oder : erstellen:\n\n2:6\n\n[1] 2 3 4 5 6\n\nseq(2,11,3)\n\n[1]  2  5  8 11\n\n\n\n1.3.1 Objekte erstellen\nBisher haben wir uns unsere Berechnungen immer direkt ausgeben lassen. Für umfangreichere Berechnungen - wir wollen ja ab dem nächsten Kapitel mit Datensätzen arbeiten - wollen wir aber die Zwischenschritte speichern.\nErgebnisse lassen sich mit einem <- unter einem beliebigen Namen als Objekt speichern. Dann wird R uns nicht das Ergebnis anzeigen, sondern den Befehl in der Konsole wiederholen:\n\nx <- 4/2\n\nIm Fenster “Environment” rechts oben sehen wir jetzt das abgelegte Objekt x:\n\n\n\n\nWir können es später wieder aufrufen:\n\nx\n\n[1] 2\n\n\nAußerdem können wir Objekte in Rechnungen weiter verwenden - wir setzen einfach x ein und erstellen zB. y:\n\ny <- x * 5\ny\n\n[1] 10\n\n\n\n\n\n\n\n\n1.3.2 Mehrere Werte ablegen\nMit c() lassen sich mehrere Werte unter einem Objekt ablegen und auch mit diesen lässt sich rechnen:\n\nx1 <- c(1,2,3)\nx1\n\n[1] 1 2 3\n\nx1* 2\n\n[1] 2 4 6\n\n\nMit length() können wir die Anzahl der abgelegten Werte nachsehen:\n\nlength(x1)\n\n[1] 3\n\n\n\ny1 <- c(10,11,9)\ny1\n\n[1] 10 11  9\n\ny1/x1\n\n[1] 10.0  5.5  3.0\n\n\n\n\n1.3.3 Werte löschen\nNatürlich können wir Objekte auch wieder löschen und zwar mit rm(). Wenn wir ein nicht existierendes Objekt aufrufen bekommen wir eine Fehlermeldung:\n\nrm(x1)\nx1\n\nError in eval(expr, envir, enclos): Objekt 'x1' nicht gefunden\n\n\nMit rm(list = ls()) können alle Objekte aus dem Environment gelöscht werden.\n\n\n1.3.4 Scripte speichern\nDas Script können wir speichern, um es später wieder aufzurufen.\n\n\n\n\nWichtig ist dabei, der gespeicherten Datei die Endung “.R” zu geben, also zum Beispiel “01_Script.R”.\n\n\n\n\n\n1.3.5 Kommentare\nNeben den eigentlichen Befehlen sind Kommentare ein zentraler Bestandteil einer Datenanalyse-Syntax. Nur so können künftige Nutzende (insbesondere wir selbst in 3 Wochen oder 2 Jahren) nachvollziehen was passiert. Kommentare in R können mit # eingefügt werden:\n\n2+ 5 # hier steht ein Kommentar\n\n[1] 7\n\n2+ # auch hier kann ein Kommentar stehen\n  5\n\n[1] 7\n\n\n\n( 2 + # ein\n    3) * # kommentar\n  2 # über mehrere Zeilen\n\n[1] 10\n\n\nTipp: Erstellen Sie sich am besten sofort einen Ordner, in dem Sie alle R Scripte und Datensätze aus dieser Veranstaltung gesammelt ablegen.\n\n\n1.3.6 Skripte strukturieren\n\n# Überschrift 1 ----\n\n## Abschnit 1.1 ----\n3+2*4\n3+2*3\n## Abschnit 1.2 ----\n3+2*sqrt(3)\n\n# Überschrift 2 ----\nx <- c(2,6,8,2,35)\ny <- seq(2,10,2)\n\ny/x"
  },
  {
    "objectID": "01_intro.html#übungen",
    "href": "01_intro.html#übungen",
    "title": "1  Einstieg in R",
    "section": "1.4 Übungen",
    "text": "1.4 Übungen\n\nLegen Sie die Anzahl der Studierenden an der Uni Oldenburg (15643) unter stud ab.\nLegen Sie die Anzahl der Professuren an der Uni Oldenburg (210) unter prof ab.\nBerechnen Sie die Anzahl der Studierenden pro Professur an der Uni Oldenburg indem Sie die Objekte stud und prof verwenden.\nLegen Sie das Ergebnis unter studprof ab und rufen Sie das das Objekt noch einmal auf!\nSehen Sie die erstellten Variablen im Environment-Fenster?\nLegen Sie die Studierendenzahlen der Uni Bremen (19173), Uni Vechta (5333) und Uni Oldenburg (15643) zusammen unter studs ab.\nLegen Sie die Zahl der Profs der Uni Bremen (322), Uni Vechta (67) und Uni Oldenburg (210) zusammen unter profs ab.\nBerechnen die Anzahl der Studierenden pro Professur für alle drei Universitäten.\nSie möchten zusätzlich die Zahl der Studierenden (14000) und Professuren (217) der Uni Osnabrück in studs und profs ablegen. Wie gehen Sie vor?\nBerechnen Sie für alle vier Universitäten das Verhältnis von Studierenden und Professuren!\nLöschen Sie das Objekt stud. Woran erkennen Sie, dass das funktioniert hat?\nLöschen Sie alle Objekte aus dem Environment. Woran erkennen Sie, dass das funktioniert hat?"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Links & Weiterführendes",
    "section": "",
    "text": "In diesem Kurs haben wir die Pipe %>% aus {tidyverse} (streng genommen aus dem Paket {magrittr}) kennen gelernt. Mit dem Update auf R 4.1 wurde in base R ebenfalls eine Pipe |> eingeführt und Hilfeseiten usw. ersetzen langsam, aber sicher %>% durch |>. Für (nahezu) alle Anwendungen, die wir kennengelernt haben, verhalten sich beide Pipes identisch - und nachdem am BIBB R die R-Version 4.0.5 zur Verfügung steht, haben wir uns an ‘alte Variante’ gehalten. Letztlich spricht aber nichts dagegen, nach einem Update auf |> umzusteigen - oder einfach bei %>% zu bleiben.\n\nUnter anderem steht hier mehr zu den Unterschieden zwischen beiden Pipes. Außerdem bietet dieser Blogbeitrag einen guten Überblick zu den Fallstricken beim Umstieg von %>% auf |>."
  },
  {
    "objectID": "references.html#anonymfun",
    "href": "references.html#anonymfun",
    "title": "Links & Weiterführendes",
    "section": "Anonyme Funktionen: .x vs. /(x)",
    "text": "Anonyme Funktionen: .x vs. /(x)\nMit R 4.1.0 wurde in base R eine neue ‘anonymous function short hand’ eingeführt, welche die ‘formula syntax’ Schreibweise ~mean(.x) ablöst, die wir in Kapitel 6 kennen gelernt haben. In der neuen base R wäre das \\(x) mean(x) geschrieben.\nAus der {purrr} release notes für Version 1.0.0 (Dezember 2022): We believe that it’s better to use these new base tools because they work everywhere: the base pipe doesn’t require that you load magrittr and the new function shorthand works everywhere, not just in purrr functions. Additionally, being able to specify the argument name for the anonymous function can often lead to clearer code.\nDementsprechend würde die Anwendung in across() wie folgt aussehen:\n\nsat_small <- haven::read_dta(\"./data/BIBBBAuA_2018_suf1.0.dta\",n_max = 16) %>% \n    select(F1450_04,F1450_05,F1450_06) %>% \n    slice(12:16)\n\n# formula syntax\nsat_small %>% \n  mutate(across(matches(\"F1450\"),~mean(.x)))\n# anonymous function short hand\nsat_small %>% \n  mutate(across(matches(\"F1450\"),\\(x) mean(x) ))\n\nIn diesem Skript habe ich auf die bisherige ‘formula syntax’ Schreibweise zurück gegriffen, da aktuell noch die meisten Hilfeseite mit dieser Syntax arbeiten."
  },
  {
    "objectID": "references.html#quarto",
    "href": "references.html#quarto",
    "title": "Links & Weiterführendes",
    "section": "Quarto",
    "text": "Quarto\nQuarto ist eine Erweiterung/Weiterentwicklung von RMarkdown. Allerdings erfordert Quarto eine separate Installation, mehr Infos."
  },
  {
    "objectID": "references.html#einführungen-in-r",
    "href": "references.html#einführungen-in-r",
    "title": "Links & Weiterführendes",
    "section": "Einführungen in R",
    "text": "Einführungen in R\nEine Sammlung von Lehrskripten und Unterlagen aus verschiedenen Kontexten zum selbst weiter lernen:\nR for Data Science das Standardwerk für Datenanalysen mit {tidyverse} - sehr intuitive Einführung, Fokus auf Data Science\nProblemorientiere Einführungen in spezifische Anwendungen “do more with R”\nTen simple rules for teaching yourself R\nModerne Datenanalyse mit R: Deutschsprachige Einführung in {tidyverse}\nR for the Rest of Us bietet viele Tutorials und freie Kurse an, unter anderem auch viele YouTube Videos.\nStata 2 R richtet sich alle Anwender*innen von Stata, die auf R umsteigen möchten. Allerdings wird hier anstelle des {tidyverse} das Paket {data.table} für die Datenaufbereitung gezeigt. {data.table} ist auf der einen Seite sehr schnell, jedoch von der Syntaxlogik her etwas umständlicher als das {tidyverse}. Für alle, die mit sehr großen Datensätzen arbeiten lohnt es sich aber, {data.table} auszuprobieren."
  },
  {
    "objectID": "references.html#beispiel-für-vollständiges-paper-geschrieben-mit-rmarkdown",
    "href": "references.html#beispiel-für-vollständiges-paper-geschrieben-mit-rmarkdown",
    "title": "Links & Weiterführendes",
    "section": "Beispiel für vollständiges Paper geschrieben mit RMarkdown",
    "text": "Beispiel für vollständiges Paper geschrieben mit RMarkdown\nPaper zu einem Beispieldatensatz, komplett in R Markdown geschrieben\nHier findet ihr den Source-Code"
  },
  {
    "objectID": "references.html#cheatsheets",
    "href": "references.html#cheatsheets",
    "title": "Links & Weiterführendes",
    "section": "Cheatsheets",
    "text": "Cheatsheets\nEine Sammlung an Cheatsheets für eine breite Palette an Anwendungen gibt es hier.\n\nDatenvisualisierung mit {ggplot2}\nDatensätze bearbeiten mit {dplyr}\nDatensätze erstellen/reshapen mit {tidyr}"
  },
  {
    "objectID": "references.html#ggplot2",
    "href": "references.html#ggplot2",
    "title": "Links & Weiterführendes",
    "section": "{ggplot2}",
    "text": "{ggplot2}\nEine große Stärke von ggplot2 sind die zahlreichen Erweiterungen, welche beispielsweise ermöglichen\n\nmehrere Grafiken zu kombinieren mit {patchwork}\nKarten zu erstellen mit sf, weitere Link\nfortgeschrittene Textformatierungen zu verwenden mit {ggtext}\nGrafiken als Animation zu erstellen {gganimate} - eine Einführung oder hier\nLogos in in {ggplot2} einfügen mit {ggpath}\n\nEine Übersicht zu Erweiterungspakteten für {ggplot2} findet sich hier\nAuch The R Graph Gallery bietet eine hervorragende Übersicht zu Darstellungsmöglichkeiten mit Syntaxbeispielen für {ggplot2}.\n\nTutorial von Cédric Scherer\nSession zu intuitiveren Grafiken von Cara Thompson"
  },
  {
    "objectID": "references.html#purrr",
    "href": "references.html#purrr",
    "title": "Links & Weiterführendes",
    "section": "Fortgeschrittene Anwendung von lapply()/map() mit selbstgeschriebenen Funktionen",
    "text": "Fortgeschrittene Anwendung von lapply()/map() mit selbstgeschriebenen Funktionen\n\nUmfangreiche Einführung in loops mit map() und weiteren Funktionen aus {purrr} Hendrik van Broekhuizen\nModellserien: Blog von Tim Tiefenbach zu eleganten Möglichkeiten"
  },
  {
    "objectID": "references.html#regex",
    "href": "references.html#regex",
    "title": "Links & Weiterführendes",
    "section": "regex",
    "text": "regex\nFür die Arbeit mit Textvariablen sind regular expressions (regex) eine große Hilfe. Damit lassen sich beispielsweise Textabschnitte nach bestimmten Zeichenfolgen durchsuchen, diese ersetzen usw. Der Blog von Joshua C. Fjelstul ist ein guter Einstieg. Darüber hinaus gibt es ein hilfreiches Cheatsheet zu regex in R und das regex -Paket {stringr}"
  },
  {
    "objectID": "references.html#weiteres",
    "href": "references.html#weiteres",
    "title": "Links & Weiterführendes",
    "section": "Weiteres",
    "text": "Weiteres\n{easystats} bietet eine Sammlung von Paketen, welche statische Auswertungen erleichtern und vereinheitlichen. Gleichzeitig geht diese Vereinheitlichung aber mit einer beschränkteren Flexibilität einher - das ist Geschmackssache und kommt auf den Anwendungsfall an. Wir haben aus dem easystats-Universum unter anderem {performance} und {effectsize} kennengelernt.\nEreigniszeitmodelle / Event History Modellung / Survival Analysis"
  },
  {
    "objectID": "01_intro.html#installation-und-einrichten-von-r-rstudio",
    "href": "01_intro.html#installation-und-einrichten-von-r-rstudio",
    "title": "1  Einstieg in R",
    "section": "1.1 Installation und Einrichten von R & RStudio",
    "text": "1.1 Installation und Einrichten von R & RStudio\nBei R handelt es sich um ein vollständig kostenloses Programm, das Sie unter CRAN herunterladen können. Ebenfalls kostenlos ist die Erweiterung RStudio, die Sie unter hier herunterladen können. RStudio erweitert R um eine deutlich informativere und ansprechendere Oberfläche, Hilfe und Auto-Vervollständigung beim Schreiben von Syntax und insgesamt eine verbesserte Nutzeroberfläche. Jedoch ist RStudio eine Erweiterung von R, sodass Sie beide Programme benötigen.\n\n\n\n\n\n\nNote\n\n\n\nInstallieren Sie zuerst R und dann RStudio, dann erkennt RStudio die installierte R-Version und die beiden Programme verbinden sich in der Regel automatisch. R ist dabei sozusagen der Motor, RStudio unser Cockpit. Wir könnten direkt mit R arbeiten, aber mit RStudio haben wir eine komfortablere Option und einen besseren Überblick.\n\n\n\n\n\n\n \n\n\nFigure 1.1: R und RStudio"
  },
  {
    "objectID": "02_intro.html",
    "href": "02_intro.html",
    "title": "2  Arbeiten mit Datensätzen in R",
    "section": "",
    "text": "(Spätes) Vorwort zu R und der Befehlsstruktur\nKlingt gut, oder?\nEin paar allgemeine Aspekte, in denen sich das Arbeiten mit R von dem mit einigen anderen Programmen unterscheidet:\n- R stoppt nicht notwendigerweise bei einem Syntaxfehler, sondern versucht den Rest der Befehle auszuführen. Aber: RStudio stoppt ab Version 2022.07 bei einem Syntaxfehler.\nIn der ersten Session haben wir einige Schritte mit der Taschenrechnerfunktion in R unternommen. Die wirkliche Stärke von R ist aber die Verarbeitung von Daten - los geht’s."
  },
  {
    "objectID": "02_intro.html#datenstrukturen-in-r-data.frame",
    "href": "02_intro.html#datenstrukturen-in-r-data.frame",
    "title": "2  Arbeiten mit Datensätzen",
    "section": "2.1 Datenstrukturen in R: data.frame",
    "text": "2.1 Datenstrukturen in R: data.frame\nIm vorherigen Kapitel haben wir die Studierendenzahlen der Uni Bremen (19173), Uni Vechta (5333) und Uni Oldenburg (15643) zusammen unter studs abgelegt und mit den in profs abgelegten Professurenzahlen ins Verhältnis gesetzt. Das funktioniert soweit gut, allerdings ist es übersichtlicher, zusammengehörige Werte auch zusammen ablegen. Dafür gibt es in R data.frame. Wir können dazu die beiden Objekte in einem Datensatz ablegen, indem wir sie in data.frame eintragen und das neue Objekt unter dat1 ablegen. Wenn wir dat1 aufrufen sehen wir, dass die Werte zeilenweise zusammengefügt wurden:\n\nstuds &lt;- c(19173,5333,15643)    # Studierendenzahlen unter \"studs\" ablegen \nprofs       &lt;- c(322,67,210)    # Prof-Zahlen unter \"profs\" ablegen\ndat1_orig &lt;- data.frame(studs, profs)\ndat1_orig\n\n  studs profs\n1 19173   322\n2  5333    67\n3 15643   210\n\n\n\ndat1 &lt;- data.frame(studs = c(19173,5333,15643), \n                   profs = c(322,67,210),\n                   gegr  = c(1971,1830,1973)) # ohne zwischen-Objekte\ndat1    # zeigt den kompletten Datensatz an\n\n  studs profs gegr\n1 19173   322 1971\n2  5333    67 1830\n3 15643   210 1973\n\n\nIn der ersten Zeile stehen also die Werte der Uni Bremen, in der zweiten Zeile die Werte der Uni Vechta usw. Die Werte können wir dann mit datensatzname$variablenname aufrufen. So können wir die Spalte profs anzeigen lassen:\n\ndat1$profs \n\n[1] 322  67 210\n\n\nMit colnames()/names() können wir die Variablen-/Spaltennamen des Datensatzes anzeigen lassen, zudem können wir mit nrow und ncol die Zahl der Zeilen bzw. Spalten aufrufen:\n\ncolnames(dat1) ## Variablen-/Spaltennamen anzeigen\n\n[1] \"studs\" \"profs\" \"gegr\" \n\nnames(dat1) ## Variablen-/Spaltennamen anzeigen\n\n[1] \"studs\" \"profs\" \"gegr\" \n\nncol(dat1) ## Anzahl der Spalten/Variablen\n\n[1] 3\n\nnrow(dat1) ## Anzahl der Zeilen/Fälle\n\n[1] 3\n\n\nNeue zusätzliche Variablen können durch datensatzname$neuevariable in den Datensatz eingefügt werden:\n\ndat1$stu_prof &lt;- dat1$studs/dat1$profs\n## dat1 hat also nun eine Spalte mehr:\nncol(dat1) \n\n[1] 4\n\ndat1\n\n  studs profs gegr stu_prof\n1 19173   322 1971 59.54348\n2  5333    67 1830 79.59701\n3 15643   210 1973 74.49048\n\n\nWir können auch ein oder mehrere Wörter in einer Variable ablegen, jedoch müssen Buchstaben/Wörter immer in \"\" gesetzt werden.\n\ndat1$uni &lt;- c(\"Uni Bremen\",\"Uni Vechta\", \"Uni Oldenburg\")\ndat1\n\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2  5333    67 1830 79.59701    Uni Vechta\n3 15643   210 1973 74.49048 Uni Oldenburg\n\n\nMit View(dat1) öffnet sich zudem ein neues Fenster, in dem wir den gesamten Datensatz ansehen können:\n\nView(dat1)"
  },
  {
    "objectID": "02_intro.html#variablentypen",
    "href": "02_intro.html#variablentypen",
    "title": "2  Arbeiten mit Datensätzen",
    "section": "2.2 Variablentypen",
    "text": "2.2 Variablentypen\nDamit haben wir bisher zwei Variablentypen kennen gelernt: numeric (enthält Zahlen) und character (enthält Text oder Zahlen, die als Text verstanden werden sollen). Darüber hinaus gibt es noch weitere Typen, die besprechen wir wenn sie nötig sind, zB. gibt es factor-Variablen, die eine vorgegebene Sortierung und Werteuniversum umfassen oder logische Variablen. Vorerst fokussieren wir uns auf character und numeric Variablen. Mit class() kann die Art der Variable untersucht werden oder mit is.numeric() bzw. is.character() können wir abfragen ob eine Variable diesem Typ entspricht:\n\nclass(dat1$profs)\n\n[1] \"numeric\"\n\nclass(dat1$uni)\n\n[1] \"character\"\n\nis.numeric(dat1$profs)\n\n[1] TRUE\n\nis.character(dat1$profs)\n\n[1] FALSE\n\n\nMit as.character() bzw. as.numeric() können wir einen Typenwechsel erzwingen:\n\nas.character(dat1$profs) ## die \"\" zeigen an, dass die Variable als character definiert ist\n\n[1] \"322\" \"67\"  \"210\"\n\n\nDas ändert erstmal nichts an der Ausgangsvariable dat1$profs:\n\nclass(dat1$profs)\n\n[1] \"numeric\"\n\n\nWenn wir diese Umwandlung für dat1$profs behalten wollen, dann müssen wir die Variable überschreiben:\n\ndat1$profs &lt;- as.character(dat1$profs)\ndat1$profs \n\n[1] \"322\" \"67\"  \"210\"\n\nclass(dat1$profs)\n\n[1] \"character\"\n\n\nMit character-Variablen kann nicht gerechnet werden, auch wenn sie Zahlen enthalten:\n\ndat1$profs / 2 \n\nError in dat1$profs/2: nicht-numerisches Argument für binären Operator\n\n\nWir können aber natürlich dat1$profs spontan mit as.numeric umwandeln, um mit den Zahlenwerten zu rechnen:\n\nas.numeric(dat1$profs)\n\n[1] 322  67 210\n\nas.numeric(dat1$profs) / 2\n\n[1] 161.0  33.5 105.0\n\n\nWenn wir Textvariablen in numerische Variablen umwandeln, bekommen wir NAs ausgegeben. NA steht in R für fehlende Werte:\n\nas.numeric(dat1$uni)\n\nWarning: NAs durch Umwandlung erzeugt\n\n\n[1] NA NA NA\n\n\nR weiß (verständlicherweise) also nicht, wie die Uni-Namen in Zahlen umgewandelt werden sollen.\n\n\n\n\n\n\nTip\n\n\n\nNicht selten ist ein Problem bei einer Berechnung auf den falschen Variablentypen zurückzuführen.\n\n\n\n2.2.1 Übung"
  },
  {
    "objectID": "02_intro.html#packages",
    "href": "02_intro.html#packages",
    "title": "2  Arbeiten mit Datensätzen",
    "section": "2.3 Pakete in R",
    "text": "2.3 Pakete in R\nIm nächsten Schritt möchten wir jetzt nur einige Zeilen (Fälle) und/oder Spalten (Variablen) auswählen. Dazu verwenden wir das Paket {dplyr}2.\nPakete sind Erweiterungen für R, die zusätzliche Funktionen beinhalten.  Pakete müssen einmalig installiert werden und dann vor der Verwendung in einer neuen Session (also nach jedem Neustart von R/RStudio) geladen werden. install.packages() leistet die Installation, mit library() werden die Pakete geladen:\n\ninstall.packages(\"Paket\") # auf eurem PC nur einmal nötig\nlibrary(Paket) # nach jedem Neustart nötig\n\nHäufig werden bei install.packages() nicht nur das angegebene Paket, sondern auch eine Reihe weiterer Pakete heruntergeladen, die sog. “dependencies”. Das sind Pakete, welche im Hintergrund verwendet werden, um die Funktionen des eigentlich gewünschten Pakets zu ermöglichen. Also nicht erschrecken, wenn die Installation etwas umfangreicher ausfällt.\nMit install.packages() schrauben wir sozusagen die Glühbirne in R, mit library() betätigen wir den Lichtschalter, sodass wir die Befehle aus dem Paket auch verwenden können. Mit jedem Neustart geht die Glühbirne wieder aus und wir müssen sie mit library() wieder aktivieren. Das hat aber den Vorteil, dass wir nicht alle Glühbirnen auf einmal anknipsen müssen, wenn wir R starten.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ninstall.packages() im IAB-Netzwerk\n\n\n\nAufgrund der VPN-Einstellungen im IAB muss in R folgende Option gesetzt werden, damit Downloads möglich sind:\noptions(download.file.method = \"wininet\")\nDazu bieten sich zwei Möglichkeiten:\n\nnach jedem Neustart von RStudio vor install.packages() mit setzen:\n\n\noptions(download.file.method = \"wininet\")\ninstall.packages()\n\n\ndiese Option permanent “verankern”: wer den Befehl nicht zu Beginn jeden R-Scripts aufführen möchte, kann ihn in die Rprofile-Datei (Rprofile.site) mit globalen Einstellungen aufnehmen. Diese Datei liegt beim BIBB Arbeitsgerät unter folgendem Pfad: C:\\RforWindows_4_2_1\\etc Mehr zu RProfile\n\n\n\n\n\n\n\n\n\nPakete einmalig laden\n\n\n\n\n\nNeben library() gibt es auch die Möglichkeit, Funktionen aus Paketen mit :: aufzurufen:\n\npaket::function()\n\nDiese Option wird häufig verwendet, wenn lediglich eine Funktion aus einem Paket einmalig verwendet wird und oder um deutlich zu machen, aus welchem Paket die verwendete Funktion kommt. Das kann auch bei Problemen mit einem Befehl hilfreich sein: evtl. wurde ein weiteres Paket mit einem gleichnamigen Befehl geladen - dann wird der erste Befehl überschrieben (meist mit einer Warnung), die bespielweise so aussehen kann:\n\nDie folgenden Objekte sind maskiert von ‘package:dplyr’:\n\n    between, first, last\n\nDas folgende Objekt ist maskiert ‘package:purrr’:\n\n    transpose\n\nDas kann umgangen werden, wenn gewisse Pakte gar nicht vollständig geladen, sondern lediglich die nötigen Funktionen mit :: aufgerufen werden.\n\n\n\n\n\n\n\n\n\nWenn keine Internetverbindung besteht\n\n\n\n\n\nUnter R Packages können die benötigten Pakete heruntergeladen werden. Nachdem wir das Paket als .zip-Datei gespeichert haben, wir mit folgendem Befehl das Paket in der R-Umgebung installieren:\n\n# Installation von Paket \"XML\"\ninstall.packages(\"E:/XML_3.98-1.3.zip\", repos = NULL, type = \"source\")"
  },
  {
    "objectID": "02_intro.html#tidyverse",
    "href": "02_intro.html#tidyverse",
    "title": "2  Arbeiten mit Datensätzen",
    "section": "2.4 {tidyverse}",
    "text": "2.4 {tidyverse}\nWir werden in diesem Kurs vor allem mit Paketen aus dem {tidyverse} arbeiten. tidyverse ist eine Sammlung an Paketen, die übergreifende Syntaxlogik haben und so besonders gut miteinander harmonisieren und eine riesige Bandbreite an Anwendungsfällen abdecken. Mit\n\ninstall.packages(\"tidyverse\")\n\nwerden folgende Pakete installiert:\nbroom, conflicted, cli, dbplyr, dplyr, dtplyr, forcats, ggplot2, googledrive, googlesheets4, haven, hms, httr, jsonlite, lubridate, magrittr, modelr, pillar, purrr, ragg, readr, readxl, reprex, rlang, rstudioapi, rvest, stringr, tibble, tidyr, xml2, tidyverse\nWir werden einige im Laufe des Kurses kennen lernen. Das zunächst wichtigste ist {dplyr}, welches unter anderem die Auswahl von Fällen und Variablen erleichtert:\n\n\n\n\n\nDarstellung basierend auf dem {dplyr} Cheatsheet\n\n\n\n\n\ninstall.packages(\"tidyverse\") \n# installiert die komplette Paketsammlung des tidyverse"
  },
  {
    "objectID": "02_intro.html#zeilen-auswählen-mit-slice",
    "href": "02_intro.html#zeilen-auswählen-mit-slice",
    "title": "2  Arbeiten mit Datensätzen",
    "section": "2.5 Zeilen auswählen mit slice()",
    "text": "2.5 Zeilen auswählen mit slice()\n\nlibrary(tidyverse) # nach einmaligem install.packages(\"tidyverse\")\n\nEine erste Funktion aus dem {tidyverse} ist slice(), mit welcher wir Zeilen auswählen können:\n\nslice(dat1,1)\n\n  studs profs gegr stu_prof        uni\n1 19173   322 1971 59.54348 Uni Bremen\n\n2:3 # ergibt eine Zahlenfolge\n\n[1] 2 3\n\nslice(dat1,2:3)\n\n  studs profs gegr stu_prof           uni\n1  5333    67 1830 79.59701    Uni Vechta\n2 15643   210 1973 74.49048 Uni Oldenburg\n\nc(1,3) # Vektor mit Werten\n\n[1] 1 3\n\nslice(dat1,c(1,3))\n\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2 15643   210 1973 74.49048 Uni Oldenburg"
  },
  {
    "objectID": "02_intro.html#filter",
    "href": "02_intro.html#filter",
    "title": "2  Arbeiten mit Datensätzen",
    "section": "2.6 Beobachtungen auswählen mit filter()",
    "text": "2.6 Beobachtungen auswählen mit filter()\nNachdem wir zunächst das Paket für filter() installiert haben (das ist {dplyr}) müssen wir das Paket noch mit library() laden:\n\nfilter(dat1,uni == \"Uni Oldenburg\", studs &gt; 1000)\n\n  studs profs gegr stu_prof           uni\n1 15643   210 1973 74.49048 Uni Oldenburg\n\n\nDie Auswahl ändert das Ausgangsobjekt dat1 aber nicht:\n\ndat1\n\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2  5333    67 1830 79.59701    Uni Vechta\n3 15643   210 1973 74.49048 Uni Oldenburg\n\n\nMöchten wir das Ergebnis unserer Auswahl mit filter() für weitere Schritte behalten, können wir unser Ergebnis in einem neuen data.frame-Objekt ablegen:\n\nueber_10tsd &lt;- filter(dat1, studs &gt; 10000)\nueber_10tsd\n\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2 15643   210 1973 74.49048 Uni Oldenburg\n\nclass(ueber_10tsd)\n\n[1] \"data.frame\"\n\n\n\n2.6.1 Auswahloperatoren\nR und {dplyr} stellen uns einige weitere Operatoren zur Auswahl von Zeilen zu Verfügung:\n\n&lt;= und &gt;=\n| oder\n%in% “eines von”\nbetween() ist eine Hilfsfunktion aus {dplyr} für Wertebereiche\n\n\nfilter(dat1, studs &gt;= 10000)\nfilter(dat1, studs &lt;= 10000)\nfilter(dat1,studs &gt; 10000 | profs &lt; 200) # mehr als 10.000 Studierende *oder* weniger als 200 Professuren\nfilter(dat1, gegr %in% c(1971,1830)) # gegründet 1971 oder 1830\nfilter(dat1, between(gegr,1971,1830)) # gegründet zwischen 1971 und 1830 (einschließlich)"
  },
  {
    "objectID": "02_intro.html#variablentypen-ii-logical",
    "href": "02_intro.html#variablentypen-ii-logical",
    "title": "2  Arbeiten mit Datensätzen",
    "section": "2.7 Variablentypen II: logical",
    "text": "2.7 Variablentypen II: logical\nDiese Auswahl basiert auf einem dritten Variablentyp: ‘logical’, also logische Werte mit TRUE oder FALSE. Wenn wir mit ==, &gt; oder &lt; eine Bedingung formulieren, dann erstellen wir eigentlich einen logischen Vektor in der selben Länge wie die Daten:\n\ndat1$studs &gt; 10000 # ist die Studi-Zahl größer 10000?\n\n[1]  TRUE FALSE  TRUE\n\ndat1$more10k &lt;-  dat1$studs &gt; 10000 # ist die Studi-Zahl größer 10000?\n\n\ndat1\n\n  studs profs gegr stu_prof           uni more10k\n1 19173   322 1971 59.54348    Uni Bremen    TRUE\n2  5333    67 1830 79.59701    Uni Vechta   FALSE\n3 15643   210 1973 74.49048 Uni Oldenburg    TRUE\n\n\nWir könnten dann auch auf Basis dieser Variable filtern:\n\nfilter(dat1,more10k)\n\n  studs profs gegr stu_prof           uni more10k\n1 19173   322 1971 59.54348    Uni Bremen    TRUE\n2 15643   210 1973 74.49048 Uni Oldenburg    TRUE"
  },
  {
    "objectID": "02_intro.html#select",
    "href": "02_intro.html#select",
    "title": "2  Arbeiten mit Datensätzen",
    "section": "2.8 Variablen auswählen mit select()",
    "text": "2.8 Variablen auswählen mit select()\nMit select() enthält {dplyr} auch einen Befehl zu Auswahl von Spalten/Variablen:\n\ndat1\n\n  studs profs gegr stu_prof           uni more10k\n1 19173   322 1971 59.54348    Uni Bremen    TRUE\n2  5333    67 1830 79.59701    Uni Vechta   FALSE\n3 15643   210 1973 74.49048 Uni Oldenburg    TRUE\n\nselect(dat1, studs,profs)\n\n  studs profs\n1 19173   322\n2  5333    67\n3 15643   210\n\n\nWir können auch hier einige Operatoren verwenden: : um einen Bereich auszuwählen oder ! als “nicht”-Operator:\n\nselect(dat1, 1:3) # Spalte 1-3\n\n  studs profs gegr\n1 19173   322 1971\n2  5333    67 1830\n3 15643   210 1973\n\nselect(dat1, !profs) # alles außer profs\n\n  studs gegr stu_prof           uni more10k\n1 19173 1971 59.54348    Uni Bremen    TRUE\n2  5333 1830 79.59701    Uni Vechta   FALSE\n3 15643 1973 74.49048 Uni Oldenburg    TRUE\n\n\nAuch hier gilt: wenn wir die Veränderungen auch weiter verwenden wollen, müssen wir sie in einem neuen Objekt ablegen:\n\ndat_ohne_profs &lt;- select(dat1, !profs) \ndat_ohne_profs\n\n  studs gegr stu_prof           uni more10k\n1 19173 1971 59.54348    Uni Bremen    TRUE\n2  5333 1830 79.59701    Uni Vechta   FALSE\n3 15643 1973 74.49048 Uni Oldenburg    TRUE\n\n\n…oder das alte überschreiben:\n\ndat1 &lt;- select(dat1, !profs) # alles außer profs\n\n\n2.8.1 Hilfsfunktionen\nselect() hat außerdem einige Hilfsfunktionen, welche die Variablenauswahl auf Basis der Variablennamen einfacher machen.\n\nstarts_with(): Variablenname beginnt mit …, bspw. select(dat1,starts_with(\"p\"))\nends_with(): Variablenname endet mit …, bspw. select(dat1,ends_with(\"p\"))\nmatches(): Variablenauswahl mit einer regular expression, bspw. select(dat1,matches(\"_\")): alle Variablen mit _ im Namen.\nnum_range(): Variablen mit Zahlenbereiche: select(etb,num_range(\"F\",1:220))\nlast_col(): Letzte Variable, für die 4.letzte Variable bspw. last_col(4)\nany_of() um eine Auswahl auf Basis eines character-Vektors zu treffen\n\n\n\nCode\n# Spalten eines `data.frame`s auf Basis der `colnames` eines data.frames auswählen möchten:\ncol_auswahl &lt;- colnames(dat1_orig)\ncol_auswahl\nselect(dat1, any_of(col_auswahl) )\n\n\n# Oder wir wollen alle Variablen, die mit \"s\" beginnen:\nselect(dat1,starts_with(\"s\"))\nselect(dat1,matches(\"^s\")) # gleiches Ergebnis mit regex\nselect(dat1,matches(\"s$\")) # alle Spalten, die mit s enden\n\n\nEs gibt noch einige weitere Hilfsfunktionen, für eine vollständige Auflistung ?select_helpers.\n\n\n2.8.2 Übung"
  },
  {
    "objectID": "02_intro.html#pipe",
    "href": "02_intro.html#pipe",
    "title": "2  Arbeiten mit Datensätzen",
    "section": "2.9 Arbeiten mit der Pipe: filter() und select() kombinieren",
    "text": "2.9 Arbeiten mit der Pipe: filter() und select() kombinieren\nWenn wir jetzt aber einige Zeilen und einige Spalten auswählen möchten, dann können wir filter() und select() kombinieren:\n\nselect(filter(dat1,studs &lt; 10000),uni)\n\n         uni\n1 Uni Vechta\n\n\nDiese Befehlsschachtel können wir mit der sog. Pipe %&gt;% auflösen. %&gt;% steht einfach für “und dann”. Die Pipe kommt aus dem Paket {magrittr}, welches wiederum Teil des tidyverse ist und automatisch mit {dplyr} geladen wird.\n\nfilter(dat1,studs &lt; 10000) %&gt;% select(uni)\n\n         uni\n1 Uni Vechta\n\n\nHäufig wird die Pipe dann so verwendet, dass zu Beginn lediglich der zu bearbeitende Datensatz steht und sich dann die Schritte anschließen:\n\ndat1 %&gt;% filter(.,studs &lt; 10000) %&gt;% select(.,uni)\n\n         uni\n1 Uni Vechta\n\n\nDer Punkt . steht jeweils für das Ergebnis des vorherigen Schritts. Hier also:\n\nRufe dat1 auf und dann (%&gt;%)\nWähle nur Zeilen aus in denen studs &lt; 10000 und dann (%&gt;%)\nBehalte nur die Spalte uni\n\nDan Punkt können wir auch weglassen:\n\ndat1 %&gt;% filter(studs &lt; 10000) %&gt;% select(uni)\n\n         uni\n1 Uni Vechta\n\n\n\n\n\n\n\n\nTip\n\n\n\n%&gt;% kann mit STRG+SHIFT+m (cmd+shift+m für Mac) eingefügt werden."
  },
  {
    "objectID": "02_intro.html#variablentyp-iii-factor---eigene-reihenfolgen-festlegen",
    "href": "02_intro.html#variablentyp-iii-factor---eigene-reihenfolgen-festlegen",
    "title": "2  Arbeiten mit Datensätzen",
    "section": "2.10 Variablentyp III: factor - eigene Reihenfolgen festlegen",
    "text": "2.10 Variablentyp III: factor - eigene Reihenfolgen festlegen\nEin weitere häufige Aufgabe in der Datenanalyse ist das Sortieren von Datensätzen. Dazu haben wir arrange() zur Verfügung:\n\ndat1 %&gt;% arrange(studs)\n\n  studs profs gegr stu_prof           uni more10k\n1  5333    67 1830 79.59701    Uni Vechta   FALSE\n2 15643   210 1973 74.49048 Uni Oldenburg    TRUE\n3 19173   322 1971 59.54348    Uni Bremen    TRUE\n\n\nDas funktioniert auch für string-Variablen:\n\ndat1 %&gt;% arrange(uni)\n\n  studs profs gegr stu_prof           uni more10k\n1 19173   322 1971 59.54348    Uni Bremen    TRUE\n2 15643   210 1973 74.49048 Uni Oldenburg    TRUE\n3  5333    67 1830 79.59701    Uni Vechta   FALSE\n\n\nWas aber, wenn wir eine fixe Ordnung vergeben möchten, die nicht der numerischen oder alphabetischen Ordnung entspricht? Hier bspw. wenn wir die Unis in folgende Ordnung bringen möchten: 1) Uni Oldenburg, 2) Uni Bremen und 3) Uni Vechta. Dabei hilft uns ein dritter Variablentyp: factor.\nMit dem Argument levels = können wir eine Reihenfolge festlegen:\n\nfactor(dat1$uni, levels = c(\"Uni Oldenburg\", \"Uni Bremen\", \"Uni Vechta\"))\n\n[1] Uni Bremen    Uni Vechta    Uni Oldenburg\nLevels: Uni Oldenburg Uni Bremen Uni Vechta\n\ndat1$uni_fct &lt;- factor(dat1$uni, \n                       levels = c(\"Uni Oldenburg\", \"Uni Bremen\", \"Uni Vechta\"))\n\nWenn wir nun nach uni_fct sortieren, dann wird die Reihenfolge der levels berücksichtigt:\n\nclass(dat1$uni_fct)\n\n[1] \"factor\"\n\ndat1 %&gt;% arrange(uni_fct)\n\n  studs profs gegr stu_prof           uni more10k       uni_fct\n1 15643   210 1973 74.49048 Uni Oldenburg    TRUE Uni Oldenburg\n2 19173   322 1971 59.54348    Uni Bremen    TRUE    Uni Bremen\n3  5333    67 1830 79.59701    Uni Vechta   FALSE    Uni Vechta\n\n\nMit desc() können wir in umgekehrter Reihenfolge sortieren:\n\ndat1 %&gt;% arrange(desc(uni_fct))\n\n  studs profs gegr stu_prof           uni more10k       uni_fct\n1  5333    67 1830 79.59701    Uni Vechta   FALSE    Uni Vechta\n2 19173   322 1971 59.54348    Uni Bremen    TRUE    Uni Bremen\n3 15643   210 1973 74.49048 Uni Oldenburg    TRUE Uni Oldenburg\n\n\nDas mag für den Moment relativ trivial erscheinen, ist aber später sehr praktisch um in Grafiken Variablen in eine gewisse Ordnung zu bringen oder in Regressionsmodellen die Referenzkategorie festzulegen.\nNatürlich können wir auch nach mehreren Variablen sortieren, dazu fügen wir einfach weitere in arrange() ein:\n\ndat1 %&gt;% arrange(desc(uni_fct), gegr, studs) \n\n  studs profs gegr stu_prof           uni more10k       uni_fct\n1  5333    67 1830 79.59701    Uni Vechta   FALSE    Uni Vechta\n2 19173   322 1971 59.54348    Uni Bremen    TRUE    Uni Bremen\n3 15643   210 1973 74.49048 Uni Oldenburg    TRUE Uni Oldenburg\n\n\n(Macht in diesem Beispiel aber wenig Sinn)\n\n2.10.1 Übung"
  },
  {
    "objectID": "02_intro.html#import",
    "href": "02_intro.html#import",
    "title": "2  Arbeiten mit Datensätzen",
    "section": "2.11 Datensätze einlesen",
    "text": "2.11 Datensätze einlesen\nIn der Regel werden wir aber Datensätze verwenden, deren Werte bereits in einer Datei gespeichert sind und die wir lediglich einlesen müssen. Dafür gibt es unzählige Möglichkeiten.\nIn diesem Seminar werden wir mit dem Campus-File des PASS arbeiten, dessen Teile als Stata-Dateien vorliegen.\nUm den Datensatz nun in R zu importieren, müssen wir R mitteilen unter welchem Dateipfad der Datensatz zu finden ist. Der Dateipfad ergibt sich aus der Ordnerstruktur Ihres Gerätes, so würde der Dateipfad im hier dargestellten Fall “D:/Kurse/R-Kurs/” lauten:\nNatürlich hängt der Dateipfad aber ganz davon ab, wo Sie den Datensatz gespeichert haben:\n\n\n\n\n\n\n\n\n\nDiesen Dateipfad müssen wir also R mitteilen.\n\n2.11.1 Projekt einrichten\nGrundsätzlich lohnt es sich, in RStudio Projekte einzurichten. Projekte sind .Rproj-Dateien , die automatisch Arbeitsverzeichnis auf den Ort setzen, an dem sie gespeichert sind. Das erleichtert das kollaborative Arbeiten: egal wer und auf welchem Gerät gerade an einem Projekt arbeitet - durch die Projektdatei sind alle Pfade immer relativ zum Projektverzeichnis. Im weiteren können auch Versionkontrolle via git, bspw. github und weitere Funktionen in der Projektdatei hinterlegt werden und so für alle Nutzenden gleich gesetzt werden. Außerdem bleiben die zuletzt geöffneten Scripte geöffnet, was ein Arbeiten an mehreren Projekten erleichtert.\n\n\n\n\n\n\n\n\n\nMit getwd() lässt sich überprüfen, ob das funktioniert hat:\n\ngetwd()\n\n\n\n[1] \"D:/Kurse/R-Kurs\"\n\n\n\n\n\n\n\n\n\n\n\nAlternativ könnten wir auch mit folgendem Befehl ein .Rproj - Projekt erstellen (hier ein Beispiel für den Aufruf eines Pakets mit ::):\n\nrstudioapi::initializeProject(path = \"D:/Kurse/R-Kurs\")\n\n\n\n2.11.2 Der Einlesebefehl\nJetzt können wir den eigentlichen Einlesebefehl read.table verwenden. Für den Pfad können wir nach file = lediglich die Anführungszeichen angeben und innerhalb dieser die Tab-Taste drücken. Dann bekommen wir alle Unterverzeichnisse und Tabellen im Projektordner angezeigt.3\n\npend &lt;- haven::read_dta(\"./orig/PENDDAT_cf_W13.dta\") \n\nDer Einlesevorgang besteht aus zwei Teilen: zuerst geben wir mit pend den Objektnamen an, unter dem R den Datensatz ablegt. Nach dem &lt;- steht dann der eigentliche Befehl read_dta(), der wiederum mehrere Optionen enthält. Als erstes geben wir den genauen Datensatznamen an - inklusive der Dateiendung.\n\nLeider nutzen Windows-Systeme \\ in den Dateipfaden - das führt in R zu Problemen. Daher müssen Dateipfade immer mit / oder alternativ mit \\\\ angegeben werden. RStudio kann zumindest etwas unterstützen, dem mit der STRG + F die Suchen & Ersetzen Funktion verwendet wird.\n\nWürden hier jetzt einfach etb eintippen bekämen wir den kompletten Datensatz angezeigt. Für einen Überblick können wir head verwenden:\n\nhead(pend)\n\n# A tibble: 6 × 123\n     pnr    hnr welle   pintj…¹ pintmon pintmod  zpsex   palter PD0400    PA0100\n   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl+l&gt; &lt;dbl+l&gt; &lt;dbl+l&gt; &lt;dbl+lb&gt; &lt;dbl+l&gt; &lt;dbl+&gt; &lt;dbl+lbl&gt; &lt;dbl+&gt;\n1 1.00e9 1.00e7 1 [Wel… 2007    5 [Mai]  1 [CAP… 2 [Wei… 36       2 [Ehe… 8     \n2 1.00e9 1.00e7 1 [Wel… 2007    5 [Mai] NA       1 [Mae… 39       2 [Ehe… 8     \n3 1.00e9 1.00e7 3 [Wel… 2009    3 [Mae…  1 [CAP… 2 [Wei… 38      -9 [Ite… 9     \n4 1.00e9 1.00e7 1 [Wel… 2007    4 [Apr…  1 [CAP… 1 [Mae… 66     -10 [Ite… 8     \n5 1.00e9 1.00e7 1 [Wel… 2007    4 [Apr…  1 [CAP… 2 [Wei… 61       3 [Ehe… 2     \n6 1.00e9 1.00e7 2 [Wel… 2008    5 [Mai]  1 [CAP… 2 [Wei… 62       3 [Ehe… 2     \n# … with 113 more variables: PA0200 &lt;dbl+lbl&gt;, PA0300 &lt;dbl+lbl&gt;,\n#   PA0445 &lt;dbl+lbl&gt;, PA0800 &lt;dbl+lbl&gt;, PA0900 &lt;dbl+lbl&gt;, PA1000 &lt;dbl+lbl&gt;,\n#   PSM0100 &lt;dbl+lbl&gt;, PEO0100a &lt;dbl+lbl&gt;, PEO0100b &lt;dbl+lbl&gt;,\n#   PEO0100c &lt;dbl+lbl&gt;, PEO0100d &lt;dbl+lbl&gt;, PEO0100e &lt;dbl+lbl&gt;,\n#   PEO0200a &lt;dbl+lbl&gt;, PEO0200b &lt;dbl+lbl&gt;, PEO0200c &lt;dbl+lbl&gt;,\n#   PEO0200d &lt;dbl+lbl&gt;, PEO0300a &lt;dbl+lbl&gt;, PEO0300b &lt;dbl+lbl&gt;,\n#   PEO0300c &lt;dbl+lbl&gt;, PEO0300d &lt;dbl+lbl&gt;, PEO0300e &lt;dbl+lbl&gt;, …\n\n\nMit nrow und ncol können wir kontrollieren, ob das geklappt hat. Der Datensatz sollte 28424 Zeilen und 123 Spalten haben:\n\nnrow(pend)\n\n[1] 28424\n\nncol(pend)\n\n[1] 123\n\n\nNatürlich können wir wie oben auch aus diesem, viel größeren, Datensatz Zeilen und Spalten auswählen. Zum Beispiel können wir die Daten aus dem Jahr 2006 auswählen und diese unter pend06 ablegen:\n\npend06 &lt;- pend %&gt;% filter(pintjahr == 2006)\n\nAußerdem hat pend06 natürlich deutlich weniger Zeilen als pend:\n\nnrow(pend06)\n\n[1] 168\n\n\nMöchten wir die genauen Altersangaben der Befragten aus pend06 sehen, können wir die entsprechende Spalte mit pend06$palter aufrufen:\n\npend06$palter\n\n&lt;labelled&lt;double&gt;[168]&gt;: Alter (Welle 1: gen. aus P1; ab Welle 2: beste Inf.), generiert\n  [1] 71 66 64 64 63 51 64 65 26 38 41 63 58 58 69 45 59 37 28 63 56 29 29 49 47\n [26] 66 34 22 21 37 36 58 56 80 44 65 61 66 40 53 34 70 69 54 65 62 58 54 51 57\n [51] 72 52 25 34 55 44 68 73 46 87 74 83 46 40 62 58 66 41 53 71 66 79 54 42 68\n [76] 68 81 92 70 66 68 77 44 66 66 67 62 43 35 35 52 54 20 48 48 20 41 24 22 33\n[101] 55 41 50 36 19 52 25 36 37 29 37 36 43 49 16 59 28 19 43 44 30 43 50 50 53\n[126] 52 71 43 58 58 58 38 49 30 27 50 58 26 36 44 28 19 42 44 23 20 33 24 31 32\n[151] 31 44 50 58 45 57 37 62 46 52 50 47 40 62 40 19 28 35\n\nLabels:\n value                                   label\n   -10 Item in Fragebogenversion nicht erhoben\n    -9             Item in Welle nicht erhoben\n    -8                       Unplausibler Wert\n    -4        Frage irrtuemlich nicht gestellt\n    -3                Trifft nicht zu (Filter)\n    -2                            Keine Angabe\n    -1                             Weiss nicht\n\n\nWie wir beim Überblick gesehen haben, gibt es aber noch deutlich mehr Variablen in der ETB als zpalter und nicht alle haben so aussagekräftige Namen - z.B. gkpol. Um diese Variablennamen und auch die Bedeutung der Ausprägungen zu verstehen brauchen wir das Codebuch. Außerdem können wir auf die attributes() einer Variable zurückgreifen - mehr zu labels später.\n\n\n2.11.3 Übung"
  },
  {
    "objectID": "02_intro.html#überblick-einlesen-und-exportieren",
    "href": "02_intro.html#überblick-einlesen-und-exportieren",
    "title": "2  Arbeiten mit Datensätzen",
    "section": "2.12 Überblick: Einlesen und Exportieren",
    "text": "2.12 Überblick: Einlesen und Exportieren\n\n2.12.1 Datensätze einlesen\n\nÜberblickCode\n\n\n\n\n\n\n\nDateityp\nR Funktion\nR Paket\nAnmerkung\n\n\n\n\n.csv\nread.table()\n-\nmit `sep = \";\"` Trennzeichen angeben\n\n\n.Rdata (R format)\nreadRDS\n-\n\n\n\ngroße .csv\nvroom()\n{vroom}\nmit `delim = \";\"` Trennzeichen angeben\n\n\n.dta (Stata)\nread_dta()\n{haven}\n\n\n\n.dat (SPSS)\nread_spss()\n{haven}\n\n\n\n.xlsx (Excel)\nread_xlsx()\n{readxl}\nmit `sheet = 1` Tabellenblatt angeben (funktioniert auch mit Namen)\n\n\n\n\n\n\n\n\n\n\n# csv Datei\ndat1 &lt;- read.table(file = \"Dateiname.csv\",sep = \";\")\n# Rdata\ndat1 &lt;- readRDS(file = \"Dateiname.Rdata\")\n# große csv\nlibrary(vroom)\ndat1 &lt;- vroom(file = \"Dateiname.csv\",delim = \";\")\n# Stata dta\nlibrary(haven)\ndat1 &lt;- read_dta(file = \"Dateiname.dta\")\n# SPSS sav\ndat1 &lt;- read_sav(file = \"Dateiname.sav\")\n# Excel\ndat1 &lt;- read_xlsx(path = \"Dateiname.xlsx\", sheet = \"1\")\ndat1 &lt;- read_xlsx(path = \"Dateiname.xlsx\", sheet = \"Tabellenblatt1\")\n\n\n\n\n\n\n2.12.2 Datensätze exportieren\n\nÜberblickCode\n\n\n\n\n\n\n\n\n\n\n\n\n\nDateityp\nR Funktion\nR Paket\nAnmerkung\n\n\n\n\n.Rdata (R format)\nsaveRDS()\n-\nalle Variableneigenschaften bleiben erhalten\n\n\n.csv\nwrite.table()\n-\nmit `sep = \";\"` Trennzeichen angeben\nmit row.names= F Zeilennummerierung unterdrücken\n\n\n.dta (Stata)\nwrite_dta()\n{haven}\n\n\n\n.dat (SPSS)\nwrite_spss()\n{haven}\n\n\n\n.xlsx (Excel)\nwrite.xlsx()\n{xlsx}\nmit `sheetName` ggf. Tabellenblattname angeben\n\n\n\n\n\n\n\n\n\n\n# Rdata\nsaveRDS(dat1,file = \"Dateiname.Rdata\")\n# csv\nwrite.table(dat1,file = \"Dateiname.csv\",sep = \";\",row.names = F)\n# dta\nlibrary(haven)\nwrite_dta(dat1,path = \"Dateiname.dta\")\n# sav\nlibrary(haven)\nwrite_sav(dat1,path = \"Dateiname.sav\")\n# xlsx\nlibrary(xlsx)\nwrite.xlsx(dat1,file = \"Dateiname.xlsx\", sheetName = \"Tabellenblatt 1\")\n\n\n\n\n\n\n2.12.3 Objekte exportieren\nWir können aber auch einzelne oder mehrere Objekte exportieren und später wieder einlesen:\n\nsave(studs, file = \"./data/stud_vektor.RData\")\nrm(studs)\nload(file = \"./data/stud_vektor.RData\") # studs wieder mit selbem Namen zurück im environment\n\nMehrere Objekte:\n\nsave(studs,profs, file = \"./data/meine_vektoren.RData\")\nrm(studs,profs)\nload(file = \"./data/meine_vektoren.RData\") # studs & profs mit selbem Namen zurück im environment\n\n\n\n\n\n\n\n\n\n\n\nDer Begriff speichern kann in R bisweilen zu Missverständnissen führen: Ist gemeint, einen Datensatz o.ä. (1) auf der Festplatte als .csv, .dta, .sav für andere Programme zugänglich abzulegen oder lediglich die Ergebnisse intern in R unter einem Objektnamen abzulegen? Ich vermeide daher das Wort speichern und spreche entweder von exportieren (im Fall 1 - in eine Datei schreiben) oder ablegen (Fall 2 - Ergebnisse/Werte innerhalb von R in einem Objekt abzulegen)"
  },
  {
    "objectID": "02_intro.html#hilfe-zu-paketen-und-funktionen",
    "href": "02_intro.html#hilfe-zu-paketen-und-funktionen",
    "title": "2  Arbeiten mit Datensätzen",
    "section": "2.13 Hilfe zu Paketen und Funktionen",
    "text": "2.13 Hilfe zu Paketen und Funktionen\nR Pakete kommen (häufig) mit sehr ausführlichen Hilfeseiten, die entweder direkt aus RStudio abgerufen werden können:\n\n# Hilfe zu Paketen\nvignette(\"dplyr\")\nvignette(package = \"dplyr\")\nvignette(\"rowwise\")\nhelp(\"dplyr\")\nhelp(package = \"dplyr\")\n\n\n# Hilfe zu Funktionen\n?select()\n\nAlternativ führt aber Google auch zum Ziel, bspw. R dplyr select()\nOder auf CRAN (woher auch install.packages() die Pakete bezieht):\n\n\n\n\n\nCRAN-Seite für {dplyr}"
  },
  {
    "objectID": "02_intro.html#übungen",
    "href": "02_intro.html#übungen",
    "title": "2  Arbeiten mit Datensätzen",
    "section": "2.14 Übungen",
    "text": "2.14 Übungen\n\n2.14.1 Übung 1\n\nErstellen Sie den Datensatz mit den Studierenden- & Prof-Zahlen wie gezeigt:\n\n\ndat2 &lt;- data.frame(studs = c(14954,47269 ,23659,9415 ,38079), \n                   profs = c(250,553,438 ,150,636),\n                   prom_recht = c(FALSE,TRUE,TRUE,TRUE,FALSE),\n                   gegr  = c(1971,1870,1457,1818,1995))\n\n\nSehen Sie den dat2 in Ihrem Environment?\nLassen Sie sich dat2 in der Console ausgeben.\nFügen Sie die Namen der Unis als neue Spalte in den Datensatz ein. Diese sind in dieser Reihenfolge:\n\n\nc(\"FH Aachen\",\"RWTH Aachen\",\"Uni Freiburg\",\"Uni Bonn\",\"FH Bonn-Rhein-Sieg\")\n\n\nLassen Sie sich dat2 anzeigen - in der Console oder mit View()\nBerechnen Sie das Verhältnis Studierende pro Professur und legen Sie die Ergebnisse in einer neuen Variable an. Sehen Sie sich das Ergebnis an.\n\nZurück nach oben\n\n\n2.14.2 Übung 2\n\nInstallieren Sie die Pakete des tidyverse mit install.packages(\"tidyverse\")\nVerwenden Sie wieder den data.frame dat2 aus Übung 1\nNutzen Sie filter, um sich nur die Unis mit unter 10000 Studierenden anzeigen zu lassen. (Denken Sie daran, {tidyverse} zu installieren und mit library() zu laden)\nLassen Sie sich nur die dritte Zeile von dat2 anzeigen.\nLassen Sie sich nur die Spalte gegr anzeigen.\nLassen Sie sich nur Zeilen der Hochschulen mit Promotionsrecht (prom_recht) anzeigen.\n\nZurück nach oben\n\n\n2.14.3 Übung 3\n\nVerwenden Sie weiterhin den Datensatz aus Übung 1 & 2.\nLassen Sie sich nur Hochschulen anzeigen, die 1971, 1457 oder 1995 gegründet wurden - und für diese Fälle nur den Namen und das Gründungsjahr.\nSortieren Sie den Datensatz entsprechend dieser Reihenfolge. (Legen Sie dazu eine factor-Variable an, welche die entsprechende Reihenfolge festlegt.)\n\n\nc(\"RWTH Aachen\",\"Uni Freiburg\",\"Uni Bonn\",\"FH Aachen\",\"FH Bonn-Rhein-Sieg\")\n\nZurück nach oben\n\n\n2.14.4 Übung 4\n\nErstellen Sie in Ihrem Verzeichnis für diesen Kurs ein R-Projekt\nLegen Sie die Erwerbstätigenbefragung in Ihrem Verzeichnis im Unterordner data ab.\nLesen Sie den Datensatz BIBBBAuA_2018_small.csv wie oben gezeigt in R ein und legen Sie den Datensatz unter dem Objektnamen etb_small ab.\nNutzen Sie head() und View(), um sich einen Überblick über den Datensatz zu verschaffen.\nWie viele Befragte (Zeilen) enthält der Datensatz?\nLassen Sie sich die Variablennamen von etb_small mit names() anzeigen!\nWie können Sie sich die Zeile anzeigen lassen, welche den/die Befragte*n mit der intnr 2781 enthält?\nWie alt ist der/die Befragte mit der intnr 2781?\nErstellen Sie eine neue Variable mit dem Alter der Befragten im Jahr 2022! (Das Geburtsjahr ist in der Variable S2_j abgelegt.)\nWählen Sie alle Befragten aus, die nach 1960 geboren wurden legen Sie diese Auswahl unter nach_1960 ab.\nWie viele Spalten hat nach_1960? Wie viele Zeilen?\n\nZurück nach oben\n\n\n\n* Datensatz speichern .Rdata\n\n\n* Datensatz"
  },
  {
    "objectID": "02_intro.html#anhang",
    "href": "02_intro.html#anhang",
    "title": "2  Arbeiten mit Datensätzen",
    "section": "2.15 Anhang",
    "text": "2.15 Anhang\n\n2.15.1 Alternativen zu R-Projekten\nNeben dem Einrichten eines Projekts können wir den Pfad auch mit setwd() setzen oder direkt in read.table() angeben. Das hat allerdings den Nachteil, dass diese Strategie nicht auf andere Rechner übertragbar ist: wenn jemand anderes die .Rproj-Datei öffnet, wird R automatisch die Pfade relativ zum Speicherort der Datei setzen. Das gilt auch wenn wir das Verzeichnis verschieben auf unserem Gerät - R wird automatisch das Arbeitsverzeichnis auf den neuen Speicherort setzen.\nZum Setzen des Arbeitsverzeichnis mit setwd() setzen wir in die Klammern den Pfad des Ordners ein. Wichtig dabei ist dass Sie ggf. alle \\ durch /ersetzen müssen:\n\nsetwd(\"D:/Kurse/R_IAB\")\n\nMit getwd() lässt sich überprüfen, ob das funktioniert hat:\n\ngetwd()\n\nHier sollte der mit setwd() gesetzte Pfad erscheinen.\nAlternativ können wir auch in read.table() den vollen Pfad angeben:\n\npend &lt;- haven::read_dta(\"C:/Kurse/R_IAB/orig/PENDDAT_cf_W13.dta\")\n\n\n\n2.15.2 Zeilen & Spaltenauswahl ohne {dplyr}\nNatürlich kann auch base R (also R ohne Erweiterungen wie {dplyr} Datensätze filtern usw.), dazu wird [ ] verwendet:\n\ndat1[1,1] # erste Zeile, erste Spalte\n\n[1] 19173\n\ndat1[1,]  # erste Zeile, alle Spalten\n\n  studs profs gegr stu_prof        uni more10k    uni_fct\n1 19173   322 1971 59.54348 Uni Bremen    TRUE Uni Bremen\n\ndat1[,1]  # alle Zeilen, erste Spalte (entspricht hier dat1$studs)\n\n[1] 19173  5333 15643\n\ndat1[,\"studs\"] # alle Zeilen, Spalte mit Namen studs -&gt; achtung: \"\"\n\n[1] 19173  5333 15643\n\n\nNatürlich können wir auch mehrere Zeilen oder Spalten auswählen. Dafür müssen wir wieder auf c( ) zurückgreifen:\n\ndat1[c(1,2),]  ## 1. & 2. Zeile, alle Spalten\ndat1[,c(1,3)]  ## alle Zeilen, 1. & 3. Spalte (entspricht dat1$studs & dat1$stu_prof)\ndat1[,c(\"studs\",\"uni\")] ## alle Zeilen, Spalten mit Namen studs und uni\n\nIn diese eckigen Klammern können wir auch Bedingungen schreiben, um so Auswahlen aus dat1 zu treffen.\n\ndat1 # vollständiger Datensatz\n\n  studs profs gegr stu_prof           uni more10k       uni_fct\n1 19173   322 1971 59.54348    Uni Bremen    TRUE    Uni Bremen\n2  5333    67 1830 79.59701    Uni Vechta   FALSE    Uni Vechta\n3 15643   210 1973 74.49048 Uni Oldenburg    TRUE Uni Oldenburg\n\ndat1[dat1$uni == \"Uni Oldenburg\", ] # Zeilen in denen uni gleich \"Uni Oldenburg\", alle Spalten\n\n  studs profs gegr stu_prof           uni more10k       uni_fct\n3 15643   210 1973 74.49048 Uni Oldenburg    TRUE Uni Oldenburg\n\ndat1$studs[dat1$uni == \"Uni Oldenburg\" ] # Nur Studi-Zahl nachsehen: kein Komma \n\n[1] 15643\n\n\nDas funktioniert soweit wie gewünscht und wir können das Ganze jetzt erweitern:\n\ndat1[dat1$uni == \"Uni Oldenburg\" & dat1$studs &gt; 10000, ] # & bedeutet UND\n\nWir können auch hier einen ODER-Operator verwenden:\n\ndat1[dat1$uni == \"Uni Oldenburg\" | dat1$studs &gt; 10000, ]\n\n\n\n2.15.3 select() vs $\nWenn wir mit select() eine spezifische Variable auswählen, wird trotzdem die Datenstruktur als data.frame() erhalten, während die Auswahl dat1$variablenname die Spalte als Vektor (also Wertereihe) ausgibt:\n\ndat1$studs\n\n[1] 19173  5333 15643\n\nclass(dat1$studs)\n\n[1] \"numeric\"\n\ndat1$studs/ 20\n\n[1] 958.65 266.65 782.15\n\n\nselect() erhält die Werte als Spalte eines data.frame:\n\ndat1 %&gt;% select(studs)\n\n  studs\n1 19173\n2  5333\n3 15643\n\ndat1 %&gt;% select(studs) %&gt;% class()\n\n[1] \"data.frame\"\n\ndat1 %&gt;% select(studs)/20 \n\n   studs\n1 958.65\n2 266.65\n3 782.15"
  },
  {
    "objectID": "02_intro.html#footnotes",
    "href": "02_intro.html#footnotes",
    "title": "2  Arbeiten mit Datensätzen",
    "section": "",
    "text": "In vielen anderen Programmiersprachen ist auch von Bibliotheken/“libraries” die Rede.↩︎\nEs hat sich in der R-Community etabliert, Pakete mit {} zu schreiben um sie deutlicher von Funktionen zu unterscheiden. Ich folge in diesem Skript dieser Konvention.↩︎\nManchmal kann der Datensatz aber nicht im Unterordner des Projekts liegen, dann kann natürlich auch der gesamte Pfad in read.table() angegeben werden: etb &lt;- read.table(file = \"D:/Kurse/R-Kurs/data/BIBBBAuA_2018_small.csv\", sep = \";\", header = T)↩︎"
  }
]