{
  "hash": "21898503af3763aeb79859250e2cc566",
  "result": {
    "markdown": "# Arbeiten mit Datensätzen\n\n\n\n\n\n**(Spätes) Vorwort zu R und der Befehlsstruktur**\n\n\n::: callout-note\n#\n\n1.  Alles ist ein Objekt.\n2.  Alles hat einen Namen.\n3.  Alles was wir tun basiert auf Funktionen.\n4.  Funktionen kommen aus \"packages\"[^pkg], aber wir werden auch eigene Funktionen schreiben.\n\n[^pkg]: In vielen anderen Programmiersprachen ist auch von Bibliotheken/\"libraries\" die Rede.\n\nPunkt 1. und 2. wird als [Objektorientierte Programmierung (object-orientated programming, OOP)](https://de.wikipedia.org/wiki/Objektorientierte_Programmierung) bezeichnet. Wir werden in diesem Kurs also objektorientierte Programmierung lernen.\n:::\n\nKlingt gut, oder?\n\n\n-   Funktionen sind (fast) immer Verben gefolgt von einer Klammer, bspw. `colnames()`, in welcher das zu bearbeitende Objekt angegeben wird. Das kann bspw. eine Variable oder ein Datensatz sein \n-  Außerdem werden in den Klammern auch ggf. Optionen angegeben - bspw. sehen wir unten den Einlesebefehl für `.dta`-Dateien: `read_dta(datensatz.dta, n_max = 100)`\n-  Zeilenumbrüche werden von R ignoriert, d.h. wir können einen Befehl über mehre Zeilen schreiben - bspw. um es etwas übersichtlicher zu halten:\n\n::: {.cell}\n\n```{.r .cell-code}\nfunktion(objektname1,\n         option1 = sehr_lange_Auswahl_die_sehr_lang_ist,\n         option2 = noch_eine_Auswahl_Option2)\n```\n:::\n\n\n-  Wenn wir eine Funktion durchführen mit `funktion(objektname, option1 = TRUE, option2 = FALSE)` bekommen wir das Ergebnis in der Konsole ausgegeben.\n-  Soll das Ergebnis einer Berechnung oder Operation nicht nur angezeigt werden, sondern für weitere Schritte behalten werden, muss mit `name <- ...` das Ergebnis unter `name` abgelegt werden. Das Ausgangsobjekt bleibt unverändert - außer wir überschreiben das Ausgangsobjekt explizit `name <- funktion(name)`. Hier im Skript werde ich sehr häufig den Schritt des Ablegens weglassen, weil wir ja direkt sehen wollen, was passiert. Wenn wir aber mit bisherigen Operationen weiterarbeiten wollen, dann müssen wir sie in R unter einem Objektnamen ablegen.\n- Optionen innerhalb einer `()` können auch einfach auf Basis der Reihenfolge angegeben werden\n- Mit `?funktion()` ist die Hilfe aufrufbar, bspw. `?colnames()`\n\nEin paar allgemeine Aspekte, in denen sich das Arbeiten mit R von dem mit einigen anderen Programmen unterscheidet:\n\n- ~~R stoppt nicht notwendigerweise bei einem Syntaxfehler, sondern versucht den Rest der Befehle auszuführen. *Aber:* RStudio stoppt ab [Version 2022.07](https://stackoverflow.com/questions/73567974/how-to-make-r-by-default-not-stopping-when-an-error-is-encountered-while-running/73641357#73641357) bei einem Syntaxfehler.~~\n\n- Für alle Stata-Nutzenden: kein `variable xyz already defined` mehr. Wir können alles überschreiben, ohne `, replace` oder ähnliches.\n\n- Durch die Objektorientierung haben wir die Möglichkeit mehrere Datensätze gleichzeitig geöffnet zu haben - das erhöht die Flexibilität.\n\nIn der ersten Session haben wir einige Schritte mit der Taschenrechnerfunktion in R unternommen. Die wirkliche Stärke von R ist aber die Verarbeitung von Daten - los geht's.\n\n\n## Datenstrukturen in R: `data.frame`\n\nIm vorherigen Kapitel haben wir die Studierendenzahlen der Uni Bremen (19173), Uni Vechta (5333) und Uni Oldenburg (15643) zusammen unter `studs` abgelegt und mit den in `profs` abgelegten Professurenzahlen ins Verhältnis gesetzt. Das funktioniert soweit gut, allerdings ist es übersichtlicher, zusammengehörige Werte auch zusammen ablegen. Dafür gibt es in R `data.frame`. Wir können dazu die beiden Objekte in einem Datensatz ablegen, indem wir sie in `data.frame` eintragen und das neue Objekt unter `dat1` ablegen. Wenn wir `dat1` aufrufen sehen wir, dass die Werte zeilenweise zusammengefügt wurden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstuds <- c(19173,5333,15643)    # Studierendenzahlen unter \"studs\" ablegen \nprofs       <- c(322,67,210)    # Prof-Zahlen unter \"profs\" ablegen\ndat1_orig <- data.frame(studs, profs)\ndat1_orig\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs\n1 19173   322\n2  5333    67\n3 15643   210\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 <- data.frame(studs = c(19173,5333,15643), \n                   profs = c(322,67,210),\n                   gegr  = c(1971,1830,1973)) # ohne zwischen-Objekte\ndat1    # zeigt den kompletten Datensatz an\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr\n1 19173   322 1971\n2  5333    67 1830\n3 15643   210 1973\n```\n:::\n:::\n\n\nIn der ersten Zeile stehen also die Werte der Uni Bremen, in der zweiten Zeile die Werte der Uni Vechta usw. Die Werte können wir dann mit `datensatzname$variablenname` aufrufen. So können wir die Spalte `profs` anzeigen lassen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1$profs \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 322  67 210\n```\n:::\n:::\n\n\nMit `colnames()`/`names()` können wir die Variablen-/Spaltennamen des Datensatzes anzeigen lassen, zudem können wir mit `nrow` und `ncol` die Zahl der Zeilen bzw. Spalten aufrufen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(dat1) ## Variablen-/Spaltennamen anzeigen\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"studs\" \"profs\" \"gegr\" \n```\n:::\n\n```{.r .cell-code}\nnames(dat1) ## Variablen-/Spaltennamen anzeigen\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"studs\" \"profs\" \"gegr\" \n```\n:::\n\n```{.r .cell-code}\nncol(dat1) ## Anzahl der Spalten/Variablen\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nnrow(dat1) ## Anzahl der Zeilen/Fälle\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nNeue zusätzliche Variablen können durch `datensatzname$neuevariable` in den Datensatz eingefügt werden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1$stu_prof <- dat1$studs/dat1$profs\n## dat1 hat also nun eine Spalte mehr:\nncol(dat1) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\ndat1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof\n1 19173   322 1971 59.54348\n2  5333    67 1830 79.59701\n3 15643   210 1973 74.49048\n```\n:::\n:::\n\n\nWir können auch ein oder mehrere Wörter in einer Variable ablegen, jedoch müssen Buchstaben/Wörter immer in `\"\"` gesetzt werden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1$uni <- c(\"Uni Bremen\",\"Uni Vechta\", \"Uni Oldenburg\")\ndat1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2  5333    67 1830 79.59701    Uni Vechta\n3 15643   210 1973 74.49048 Uni Oldenburg\n```\n:::\n:::\n\n\nMit `View(dat1)` öffnet sich zudem ein neues Fenster, in dem wir den gesamten Datensatz ansehen können:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nView(dat1)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](./pic/102_View.png){fig-align='center' width=45% height=35%}\n:::\n:::\n\n\n## Datentypen in R\n\nDamit haben wir bisher zwei Variablentypen kennen gelernt: numeric (enthält Zahlen) und character (enthält Text oder Zahlen, die als Text verstanden werden sollen). Zudem haben wir eine Organisationsmöglichkeit kennengelernt: `data.frame`.\n\nFür uns sind es folgende Variablentypen in R wichtig:[^vec_types]\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Paket 'gt' wurde unter R Version 4.2.3 erstellt\n```\n:::\n\n::: {.cell-output-display}\n```{=html}\n<div id=\"vxxsqggryq\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>#vxxsqggryq table {\n  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n#vxxsqggryq thead, #vxxsqggryq tbody, #vxxsqggryq tfoot, #vxxsqggryq tr, #vxxsqggryq td, #vxxsqggryq th {\n  border-style: none;\n}\n\n#vxxsqggryq p {\n  margin: 0;\n  padding: 0;\n}\n\n#vxxsqggryq .gt_table {\n  display: table;\n  border-collapse: collapse;\n  line-height: normal;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#vxxsqggryq .gt_caption {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n\n#vxxsqggryq .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#vxxsqggryq .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 3px;\n  padding-bottom: 5px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#vxxsqggryq .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#vxxsqggryq .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#vxxsqggryq .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#vxxsqggryq .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#vxxsqggryq .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#vxxsqggryq .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#vxxsqggryq .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#vxxsqggryq .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#vxxsqggryq .gt_spanner_row {\n  border-bottom-style: hidden;\n}\n\n#vxxsqggryq .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  text-align: left;\n}\n\n#vxxsqggryq .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#vxxsqggryq .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#vxxsqggryq .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#vxxsqggryq .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#vxxsqggryq .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#vxxsqggryq .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#vxxsqggryq .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#vxxsqggryq .gt_row_group_first th {\n  border-top-width: 2px;\n}\n\n#vxxsqggryq .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#vxxsqggryq .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#vxxsqggryq .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#vxxsqggryq .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#vxxsqggryq .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#vxxsqggryq .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#vxxsqggryq .gt_last_grand_summary_row_top {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: double;\n  border-bottom-width: 6px;\n  border-bottom-color: #D3D3D3;\n}\n\n#vxxsqggryq .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#vxxsqggryq .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#vxxsqggryq .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#vxxsqggryq .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#vxxsqggryq .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#vxxsqggryq .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#vxxsqggryq .gt_left {\n  text-align: left;\n}\n\n#vxxsqggryq .gt_center {\n  text-align: center;\n}\n\n#vxxsqggryq .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#vxxsqggryq .gt_font_normal {\n  font-weight: normal;\n}\n\n#vxxsqggryq .gt_font_bold {\n  font-weight: bold;\n}\n\n#vxxsqggryq .gt_font_italic {\n  font-style: italic;\n}\n\n#vxxsqggryq .gt_super {\n  font-size: 65%;\n}\n\n#vxxsqggryq .gt_footnote_marks {\n  font-size: 75%;\n  vertical-align: 0.4em;\n  position: initial;\n}\n\n#vxxsqggryq .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#vxxsqggryq .gt_indent_1 {\n  text-indent: 5px;\n}\n\n#vxxsqggryq .gt_indent_2 {\n  text-indent: 10px;\n}\n\n#vxxsqggryq .gt_indent_3 {\n  text-indent: 15px;\n}\n\n#vxxsqggryq .gt_indent_4 {\n  text-indent: 20px;\n}\n\n#vxxsqggryq .gt_indent_5 {\n  text-indent: 25px;\n}\n</style>\n<table class=\"gt_table\" data-quarto-disable-processing=\"false\" data-quarto-bootstrap=\"false\">\n  <thead>\n    <tr class=\"gt_heading\">\n      <td colspan=\"2\" class=\"gt_heading gt_title gt_font_normal gt_bottom_border\" style>Vektoren</td>\n    </tr>\n    \n    \n  </thead>\n  <tbody class=\"gt_table_body\">\n    <tr><td headers=\"class\" class=\"gt_row gt_left\"><div class='gt_from_md'><p>integer <br> double</p>\n</div></td>\n<td headers=\"Beschreibung\" class=\"gt_row gt_left\"><div class='gt_from_md'><p>Numerische Werte (<code>numeric</code>)</p>\n</div></td></tr>\n    <tr><td headers=\"class\" class=\"gt_row gt_left\"><div class='gt_from_md'><p>character</p>\n</div></td>\n<td headers=\"Beschreibung\" class=\"gt_row gt_left\"><div class='gt_from_md'><p>Text (oder als Text verstandende Zahlen)</p>\n</div></td></tr>\n    <tr><td headers=\"class\" class=\"gt_row gt_left\"><div class='gt_from_md'><p>factor</p>\n</div></td>\n<td headers=\"Beschreibung\" class=\"gt_row gt_left\"><div class='gt_from_md'><p>Text oder als Text verstandende Zahlen mit vorgegebener Sortierung und fixem Werteuniversum</p>\n</div></td></tr>\n    <tr><td headers=\"class\" class=\"gt_row gt_left\"><div class='gt_from_md'><p>logical</p>\n</div></td>\n<td headers=\"Beschreibung\" class=\"gt_row gt_left\"><div class='gt_from_md'><p><code>TRUE</code> oder <code>FALSE</code> - meist das Ergebnis eines Vergleichs (größer/kleiner/gleich)</p>\n</div></td></tr>\n  </tbody>\n  \n  \n</table>\n</div>\n```\n:::\n\n::: {.cell-output-display}\n```{=html}\n<div id=\"ualyjehzpm\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>#ualyjehzpm table {\n  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n#ualyjehzpm thead, #ualyjehzpm tbody, #ualyjehzpm tfoot, #ualyjehzpm tr, #ualyjehzpm td, #ualyjehzpm th {\n  border-style: none;\n}\n\n#ualyjehzpm p {\n  margin: 0;\n  padding: 0;\n}\n\n#ualyjehzpm .gt_table {\n  display: table;\n  border-collapse: collapse;\n  line-height: normal;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#ualyjehzpm .gt_caption {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n\n#ualyjehzpm .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#ualyjehzpm .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 3px;\n  padding-bottom: 5px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#ualyjehzpm .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#ualyjehzpm .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#ualyjehzpm .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#ualyjehzpm .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#ualyjehzpm .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#ualyjehzpm .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#ualyjehzpm .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#ualyjehzpm .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#ualyjehzpm .gt_spanner_row {\n  border-bottom-style: hidden;\n}\n\n#ualyjehzpm .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  text-align: left;\n}\n\n#ualyjehzpm .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#ualyjehzpm .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#ualyjehzpm .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#ualyjehzpm .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#ualyjehzpm .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#ualyjehzpm .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#ualyjehzpm .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#ualyjehzpm .gt_row_group_first th {\n  border-top-width: 2px;\n}\n\n#ualyjehzpm .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#ualyjehzpm .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#ualyjehzpm .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#ualyjehzpm .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#ualyjehzpm .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#ualyjehzpm .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#ualyjehzpm .gt_last_grand_summary_row_top {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: double;\n  border-bottom-width: 6px;\n  border-bottom-color: #D3D3D3;\n}\n\n#ualyjehzpm .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#ualyjehzpm .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#ualyjehzpm .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#ualyjehzpm .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#ualyjehzpm .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#ualyjehzpm .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#ualyjehzpm .gt_left {\n  text-align: left;\n}\n\n#ualyjehzpm .gt_center {\n  text-align: center;\n}\n\n#ualyjehzpm .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#ualyjehzpm .gt_font_normal {\n  font-weight: normal;\n}\n\n#ualyjehzpm .gt_font_bold {\n  font-weight: bold;\n}\n\n#ualyjehzpm .gt_font_italic {\n  font-style: italic;\n}\n\n#ualyjehzpm .gt_super {\n  font-size: 65%;\n}\n\n#ualyjehzpm .gt_footnote_marks {\n  font-size: 75%;\n  vertical-align: 0.4em;\n  position: initial;\n}\n\n#ualyjehzpm .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#ualyjehzpm .gt_indent_1 {\n  text-indent: 5px;\n}\n\n#ualyjehzpm .gt_indent_2 {\n  text-indent: 10px;\n}\n\n#ualyjehzpm .gt_indent_3 {\n  text-indent: 15px;\n}\n\n#ualyjehzpm .gt_indent_4 {\n  text-indent: 20px;\n}\n\n#ualyjehzpm .gt_indent_5 {\n  text-indent: 25px;\n}\n</style>\n<table class=\"gt_table\" data-quarto-disable-processing=\"false\" data-quarto-bootstrap=\"false\">\n  <thead>\n    <tr class=\"gt_heading\">\n      <td colspan=\"2\" class=\"gt_heading gt_title gt_font_normal gt_bottom_border\" style>Zusammengefasste Vektoren</td>\n    </tr>\n    \n    \n  </thead>\n  <tbody class=\"gt_table_body\">\n    <tr><td headers=\"class\" class=\"gt_row gt_left\"><div class='gt_from_md'><p>data.frame <br> tibble</p>\n</div></td>\n<td headers=\"Beschreibung\" class=\"gt_row gt_left\"><div class='gt_from_md'><p>Zweidimensionale Datenstruktur, die in Tabellenform organisiert ist -  tibble sind eine Weiterentwicklung des data.frame im tidyverse (mehr dazu <a href=\"#tidyverse\">gleich</a>)</p>\n</div></td></tr>\n    <tr><td headers=\"class\" class=\"gt_row gt_left\"><div class='gt_from_md'><p>list</p>\n</div></td>\n<td headers=\"Beschreibung\" class=\"gt_row gt_left\"><div class='gt_from_md'><p>Geordnete Sammlung von Vektoren unterschiedlicher Typen - kann andere Wertetypen, <code>data.frame</code> oder sogar andere Listen enthalten</p>\n</div></td></tr>\n  </tbody>\n  \n  \n</table>\n</div>\n```\n:::\n:::\n\n\n  \n[^vec_types]: Es gibt noch weitere und diese Aufzählung ignoriert die technischen Hintergründe - für eine [fortgeschrittene Einführung zu Vektoren in R hier entlang](https://r4ds.had.co.nz/vectors.html)\n\n\n\nVorerst fokussieren wir uns auf character und numerische Variablen. \nDie weiteren Typen, besprechen wir wenn sie nötig sind. \nMit `class()` kann die Art der Variable untersucht werden oder mit `is.numeric()` bzw. `is.character()` können wir abfragen ob eine Variable diesem Typ entspricht:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(dat1$profs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nclass(dat1$uni)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nis.numeric(dat1$profs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.character(dat1$profs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nMit `as.character()` bzw. `as.numeric()` können wir einen Typenwechsel erzwingen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.character(dat1$profs) ## die \"\" zeigen an, dass die Variable als character definiert ist\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"322\" \"67\"  \"210\"\n```\n:::\n:::\n\n\nDas ändert erstmal nichts an der Ausgangsvariable `dat1$profs`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(dat1$profs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\nWenn wir diese Umwandlung für `dat1$profs` behalten wollen, dann müssen wir die Variable überschreiben:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1$profs <- as.character(dat1$profs)\ndat1$profs \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"322\" \"67\"  \"210\"\n```\n:::\n\n```{.r .cell-code}\nclass(dat1$profs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\nMit `character`-Variablen kann nicht gerechnet werden, auch wenn sie Zahlen enthalten:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1$profs / 2 \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in dat1$profs/2: nicht-numerisches Argument für binären Operator\n```\n:::\n:::\n\n\nWir können aber natürlich `dat1$profs` spontan mit `as.numeric` umwandeln, um mit den Zahlenwerten zu rechnen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(dat1$profs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 322  67 210\n```\n:::\n\n```{.r .cell-code}\nas.numeric(dat1$profs) / 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 161.0  33.5 105.0\n```\n:::\n:::\n\n\nWenn wir Textvariablen in numerische Variablen umwandeln, bekommen wir `NA`s ausgegeben. `NA` steht in R für fehlende Werte:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(dat1$uni)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs durch Umwandlung erzeugt\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA NA\n```\n:::\n:::\n\n\nR weiß (verständlicherweise) also nicht, wie die Uni-Namen in Zahlen umgewandelt werden sollen.\n\n::: callout-tip\nNicht selten ist ein Problem bei einer Berechnung auf den falschen Variablentypen zurückzuführen.\n:::\n\n\n\n## Zeilen & Spalten auswählen \n\nEine typische Aufgabe in der Arbeit mit Datensätzen ist die Auswahl von Zeilen (\"Fällen\") und Spalten (\"Variablen\").  \n\nDazu stellt uns R in der Basisversion[^baseR] eine Auswahlmöglichkeit zur Verfügung, welche  \\[ \\] verwendet. Die grundlegende Struktur ist dabei `[Zeilenauswahl, Spaltenauswahl]`. Lassen wir den Part vor oder nach dem Komma leer, werden alle Zeilen/Spalten ausgewählt. Achtung: das vergessene Komma ist wohl einer *der* Fehlerquellen in R.\n\n[^baseR]: Wir werden [gleich](#packages) sehen, wie sehr Erweiterungen (\"Pakete\") uns das Arbeiten in R erleichtern.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 # vollständiger Datensatz\ndat1[1,1] # erste Zeile, erste Spalte\ndat1[1,]  # erste Zeile, alle Spalten\ndat1[,1]  # alle Zeilen, erste Spalte (entspricht hier dat1$studs)\ndat1[,\"studs\"] # alle Zeilen, Spalte mit Namen studs -> achtung: \"\"\n```\n:::\n\n\nIn diese eckigen Klammern können wir auch Bedingungen schreiben, um so Auswahlen aus `dat1` zu treffen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1[dat1$studs > 10000, ] # Zeilen in denen studs größer 10000, alle Spalten\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n3 15643   210 1973 74.49048 Uni Oldenburg\n```\n:::\n\n```{.r .cell-code}\ndat1[dat1$studs > 10000 & dat1$profs < 300, ] # & bedeutet UND\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni\n3 15643   210 1973 74.49048 Uni Oldenburg\n```\n:::\n\n```{.r .cell-code}\ndat1$profs[dat1$studs > 10000] # Nur Prof-Zahl nachsehen: kein Komma \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"322\" \"210\"\n```\n:::\n:::\n\n\n\n\n### [Übung](#data1) {#ue_1}\n\nDie Wiederholung des Datensatznamens in den `[ ]` macht die Syntax aber recht lang und etwas schreibintensiv. Daher gibt es eine bessere/bequemere Lösung.\nDazu verwenden wir das Paket `{dplyr}`[^04_intro-1]. \n\n[^04_intro-1]: Es hat sich in der R-Community etabliert, Pakete mit `{}` zu schreiben um sie deutlicher von Funktionen zu unterscheiden. Ich folge in diesem Skript dieser Konvention. \n\n\n## Pakete in R {#packages}\n\n\nPakete sind Erweiterungen für R, die zusätzliche Funktionen beinhalten. <!-- Wir haben in diesem Kapitel schon einige Beispiele kennen gelernt: mit `{dplyr}` steht uns ein komfortablerer [`filter()`](#filter) zur Verfügung und Stata- oder SPSS-Dateien können wir mit Hilfe des Pakets `haven` einlesen und erstellen.  --> Pakete müssen einmalig installiert werden und dann vor der Verwendung in einer neuen Session (also nach jedem Neustart von R/RStudio) geladen werden. `install.packages()` leistet die Installation, mit `library()` werden die Pakete geladen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"Paket\") # auf eurem PC nur einmal nötig\nlibrary(Paket) # nach jedem Neustart nötig\n```\n:::\n\n\nHäufig werden bei `install.packages()` nicht nur das angegebene Paket, sondern auch eine Reihe weiterer Pakete heruntergeladen, die sog. \"dependencies\". Das sind Pakete, welche im Hintergrund verwendet werden, um die Funktionen des eigentlich gewünschten Pakets zu ermöglichen. Also nicht erschrecken, wenn die Installation etwas umfangreicher ausfällt.\n\nMit `install.packages()` schrauben wir sozusagen die Glühbirne in R, mit `library()` betätigen wir den Lichtschalter, sodass wir die Befehle aus dem Paket auch verwenden können. Mit jedem Neustart geht die Glühbirne wieder aus und wir müssen sie mit `library()` wieder aktivieren. Das hat aber den Vorteil, dass wir nicht alle Glühbirnen auf einmal anknipsen müssen, wenn wir R starten.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Quelle: [Dianne Cook](https://twitter.com/visnut/status/1248087845589274624)](./pic/104_install-packages.jpg){fig-align='center' width=53% height=53%}\n:::\n:::\n\n\n:::{.callout-caution}\n## `install.packages()` im IAB-Netzwerk {#fdz_install}\n\nPakete werden in R standardmäßig als Download von [CRAN](https://cran.r-project.org/web/packages/available_packages_by_name.html) installiert.\nAuf der Servern im IAB ist das durch die Abkapselung vom Internet nicht möglich. \nDas schränkt die Installation von Paketen in R auf die von DIM gepflegte Sammlung unter [N:/Ablagen/D01700-Allgemein/R/bin/windows/contrib/](N:/Ablagen/D01700-Allgemein/R/bin/windows/contrib/) ein.\n\nZentrale Herausforderung der Installation aus lokalen zip-Dateien ist die Installation von *Dependencies*: Paketen, auf welche das eigentlich gewünschte Paket zurückgreift. \nBei einer Installation aus dem Internet werden die Dependencies automatisch mitinstalliert - bei einer lokalen Installation ist das nicht der Fall.\n\nAm IAB existieren einige Workarounds, aktuell habe ich am FDZ eine Lösung in Arbeit, die auf Basis einer `.Rprofile`-Datei den Befehl `fdz_install()` zur Verfügung stellt - dieser verhält sich wie der Standard-Befehl `install.packages()` (oder sollte es zumindest).\n\nDie `.Rprofile`-Datei findet sich unter `[N:\\Ablagen\\D01700-Quickablage\\Filser\\R_2023\\prog](N:\\Ablagen\\D01700-Quickablage\\Filser\\R_2023\\prog)`.\n\nLegt die `.Rprofile`-Datei in `C:\\Users\\*EUREKENNUNG*\\Documents` und startet R neu (`STRG + F10`), ihr solltet dann in der Konsole eine ähnliche  Meldung sehen:\n\n::: {.cell}\n\n```{.r .cell-code}\n----------------------------------------\nIAB-FDZ .Rprofile\nVersion 0.1\n----------------------------------------\n- Local repository: N:/Ablagen/D01700-Allgemein/R/bin/windows/contrib/4.2\n- Working directory: N:/Ablagen/D01700-FDZ/Quickablage/AndreasF/R-Kurs\n \n- Default package library: C:/Users/FilserA001.IAB/AppData/Local/R/win-library/4.2\n- HOME directory: C:/Users/FilserA001.IAB/Documents\n- R_home directory: C:/PROGRA~1/R/R-4.2.1\n----------------------------------------\n```\n:::\n\n\n\n[**Mehr zu RProfile**](https://support.posit.co/hc/en-us/articles/360047157094-Managing-R-with-Rprofile-Renviron-Rprofile-site-Renviron-site-rsession-conf-and-repos-conf)\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n# Pakete einmalig laden {#pkgdoublecolon}\n\nNeben `library()` gibt es auch die Möglichkeit, Funktionen aus Paketen mit `::` aufzurufen:\n\n::: {.cell}\n\n```{.r .cell-code}\npaket::function()\n```\n:::\n\n\nDiese Option wird häufig verwendet, wenn lediglich eine Funktion aus einem Paket einmalig verwendet wird und oder um deutlich zu machen, aus welchem Paket die verwendete Funktion kommt. Das kann auch bei Problemen mit einem Befehl hilfreich sein: evtl. wurde ein weiteres Paket mit einem gleichnamigen Befehl geladen - dann wird der erste Befehl überschrieben (meist mit einer Warnung), die bespielweise so aussehen kann:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDie folgenden Objekte sind maskiert von ‘package:dplyr’:\n\n    between, first, last\n\nDas folgende Objekt ist maskiert ‘package:purrr’:\n\n    transpose\n```\n:::\n\n\nDas kann umgangen werden, wenn gewisse Pakte gar nicht vollständig geladen, sondern lediglich die nötigen Funktionen mit `::` aufgerufen werden.\n\n:::\n\n\n## `{tidyverse}` {#tidyverse}\n\nWir werden in diesem Kurs vor allem mit Paketen aus dem [`{tidyverse}`](www.tidyverse.org/) arbeiten. tidyverse ist eine Sammlung an Paketen, die übergreifende Syntaxlogik haben und so besonders gut miteinander harmonisieren und eine riesige Bandbreite an Anwendungsfällen abdecken. Mit\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\nfdz_install(\"tidyverse\") # auf den IAB-Servern mit .Rprofile\n```\n:::\n\nwerden folgende Pakete installiert:\n\nbroom, conflicted, cli, dbplyr, dplyr, dtplyr, forcats, ggplot2, googledrive, googlesheets4, haven, hms, httr, jsonlite, lubridate, magrittr, modelr, pillar, purrr, ragg, readr, readxl, reprex, rlang, rstudioapi, rvest, stringr, tibble, tidyr, xml2, tidyverse\n\nWir werden einige im Laufe des Kurses kennen lernen. Das zunächst wichtigste ist `{dplyr}`, welches unter anderem die Auswahl von Fällen und Variablen erleichtert:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Darstellung basierend auf dem [`{dplyr}` Cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdat1)](./pic/103_dplyr.png){fig-align='center' width=80% height=80%}\n:::\n:::\n\n\nEine Installation ist aber nur der erste Schritt, jetzt müssen wir mit `library()` noch das Paket laden:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) # nach einmaligem install.packages(\"tidyverse\")\n```\n:::\n\n\n## Zeilen auswählen mit `slice()`\n\n\nEine erste Funktion aus dem `{tidyverse}` ist `slice()`, mit welcher wir Zeilen auswählen können:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslice(dat1,1) # erste Zeile\nslice(dat1,2:3) # Zeile 2-3\nslice(dat1,c(1,3)) # Zeile 1 und 3\n```\n:::\n\n\n\n## Beobachtungen auswählen mit `filter()` {#filter}\n\nMit `filter()` können wir Zeilen aus `dat1` mit Hilfe von Bedingungen auswählen:\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(dat1,uni == \"Uni Oldenburg\", studs > 1000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni\n1 15643   210 1973 74.49048 Uni Oldenburg\n```\n:::\n:::\n\n\nDie Auswahl ändert das Ausgangsobjekt `dat1` aber nicht:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2  5333    67 1830 79.59701    Uni Vechta\n3 15643   210 1973 74.49048 Uni Oldenburg\n```\n:::\n:::\n\n\nMöchten wir das Ergebnis unserer Auswahl mit `filter()` für weitere Schritte behalten, können wir unser Ergebnis in einem neuen `data.frame`-Objekt ablegen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nueber_10tsd <- filter(dat1, studs > 10000)\nueber_10tsd\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2 15643   210 1973 74.49048 Uni Oldenburg\n```\n:::\n:::\n\n\n### Auswahloperatoren\n\nR und `{dplyr}` stellen uns einige weitere Operatoren zur Auswahl von Zeilen zu Verfügung:\n\n-   `<=` und `>=`\n-   `|` oder\n-   `%in%` \"eines von\"\n-   `between()` ist eine Hilfsfunktion aus `{dplyr}` für Wertebereiche\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(dat1, studs >= 10000)\nfilter(dat1, studs <= 10000)\nfilter(dat1,studs > 10000 | profs < 200) # mehr als 10.000 Studierende *oder* weniger als 200 Professuren\nfilter(dat1, gegr %in% c(1971,1830)) # gegründet 1971 oder 1830\nfilter(dat1, between(gegr,1971,1830)) # gegründet zwischen 1971 und 1830 (einschließlich)\n```\n:::\n\n\n<!-- Erweiterte Hilfsfunktionen für `filter()`:  `if_any()` or `if_all()` -->\n\n<!-- ```{r, eval =F } -->\n<!-- pend18 %>% filter(if_any(matches(\"^F\"), ~ .x < 10)) -->\n<!-- ``` -->\n\n\n\n<!-- ## Variablentypen II: logical -->\n\n<!-- Diese Auswahl basiert auf einem dritten Variablentyp: 'logical', also logische Werte mit `TRUE` oder `FALSE`. Wenn wir mit `==`, `>` oder `<` eine Bedingung formulieren, dann erstellen wir eigentlich einen logischen Vektor in der selben Länge wie die Daten: -->\n\n<!-- ```{r} -->\n<!-- dat1$studs > 10000 # ist die Studi-Zahl größer 10000? -->\n<!-- dat1$more10k <-  dat1$studs > 10000 # ist die Studi-Zahl größer 10000? -->\n<!-- ``` -->\n\n<!-- ```{r} -->\n<!-- dat1 -->\n<!-- ``` -->\n\n<!-- Wir könnten dann auch auf Basis dieser Variable filtern: -->\n\n<!-- ```{r} -->\n<!-- filter(dat1,more10k) -->\n<!-- ``` -->\n\n## Variablen auswählen mit `select()` {#select}\n\nMit `select()` enthält `{dplyr}` auch einen Befehl zu Auswahl von Spalten/Variablen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2  5333    67 1830 79.59701    Uni Vechta\n3 15643   210 1973 74.49048 Uni Oldenburg\n```\n:::\n\n```{.r .cell-code}\nselect(dat1, studs,profs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs\n1 19173   322\n2  5333    67\n3 15643   210\n```\n:::\n:::\n\n\nWir können auch hier einige Operatoren verwenden: `:` um einen Bereich auszuwählen oder `!` als \"nicht\"-Operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(dat1, 1:3) # Spalte 1-3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr\n1 19173   322 1971\n2  5333    67 1830\n3 15643   210 1973\n```\n:::\n\n```{.r .cell-code}\nselect(dat1, !profs) # alles außer profs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs gegr stu_prof           uni\n1 19173 1971 59.54348    Uni Bremen\n2  5333 1830 79.59701    Uni Vechta\n3 15643 1973 74.49048 Uni Oldenburg\n```\n:::\n:::\n\n\nAuch hier gilt: wenn wir die Veränderungen auch weiter verwenden wollen, müssen wir sie in einem neuen Objekt ablegen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_ohne_profs <- select(dat1, !profs) \ndat_ohne_profs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs gegr stu_prof           uni\n1 19173 1971 59.54348    Uni Bremen\n2  5333 1830 79.59701    Uni Vechta\n3 15643 1973 74.49048 Uni Oldenburg\n```\n:::\n\n```{.r .cell-code}\ndat1 # unverändert\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2  5333    67 1830 79.59701    Uni Vechta\n3 15643   210 1973 74.49048 Uni Oldenburg\n```\n:::\n:::\n\n\n### Hilfsfunktionen {#selecthelpers}\n\n`select()` hat außerdem einige Hilfsfunktionen, welche die Variablenauswahl auf Basis der Variablennamen einfacher machen.\n\n-   `contains(\"b\")`: Variablenname enthält `...`, bspw. `select(dat1,contains(\"b\"))`\n-   `matches()`: Variablenauswahl mit einer [*regular expression*](https://jfjelstul.github.io/regular-expressions-tutorial/), bspw. `select(dat1,matches(\"b$\"))`: alle Variablen mit `b` am Ende des Namens.\n\n\nEs gibt noch einige weitere Hilfsfunktionen, für eine vollständige Auflistung `?select_helpers`.\n\n### [Übung](#data2) {#ue_2}\n\n## Arbeiten mit der Pipe: `filter()` und `select()` kombinieren  {#pipe}\n\n\nWenn wir jetzt aber einige Zeilen **und** einige Spalten auswählen möchten, dann können wir `filter()` und `select()` kombinieren:\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(filter(dat1,studs < 10000),uni)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         uni\n1 Uni Vechta\n```\n:::\n:::\n\nDiese Befehlsschachtel können wir mit der sog. Pipe `%>%` auflösen. `%>%` steht einfach für \"und dann\". Die Pipe kommt aus dem Paket `{magrittr}`, welches wiederum Teil des tidyverse ist und automatisch mit `{dplyr}` geladen wird. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(dat1,studs < 10000) %>% select(uni)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         uni\n1 Uni Vechta\n```\n:::\n:::\n\n\nHäufig wird die Pipe dann so verwendet, dass zu Beginn lediglich der zu bearbeitende Datensatz steht und sich dann die Schritte anschließen:\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 %>% filter(.,studs < 10000) %>% select(.,uni)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         uni\n1 Uni Vechta\n```\n:::\n:::\n\n\n\nDer Punkt `.` steht jeweils für das Ergebnis des vorherigen Schritts. Hier also:\n\n   1. Rufe `dat1` auf *und dann (`%>%`)*\n   2. Wähle nur Zeilen aus in denen `studs` < 10000 *und dann (`%>%`)*\n   3. Behalte nur die Spalte `uni`\n\nDan Punkt können wir auch weglassen:\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 %>% filter(studs < 10000) %>% select(uni)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         uni\n1 Uni Vechta\n```\n:::\n:::\n\n\n\n:::{.callout-tip}\n\n`%>%` kann mit STRG+SHIFT+m (cmd+shift+m für Mac) eingefügt werden.\n\n:::\n\n\n\n\n## Variablentyp `factor` - eigene Reihenfolgen festlegen\n\n\nEin weitere häufige Aufgabe in der Datenanalyse ist das Sortieren von Datensätzen. Dazu haben wir `arrange()` zur Verfügung:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 %>% arrange(studs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni\n1  5333    67 1830 79.59701    Uni Vechta\n2 15643   210 1973 74.49048 Uni Oldenburg\n3 19173   322 1971 59.54348    Uni Bremen\n```\n:::\n:::\n\n\nDas funktioniert auch für `string`-Variablen:\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 %>% arrange(uni)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2 15643   210 1973 74.49048 Uni Oldenburg\n3  5333    67 1830 79.59701    Uni Vechta\n```\n:::\n:::\n\n\nWas aber, wenn wir eine fixe Ordnung vergeben möchten, die nicht der numerischen oder alphabetischen Ordnung entspricht?\nHier bspw. wenn wir die Unis in folgende Ordnung bringen möchten: 1) Uni Oldenburg, 2) Uni Bremen und 3) Uni Vechta.\nDabei hilft uns ein dritter Variablentyp: `factor`.\n\nMit dem Argument `levels =` können wir eine Reihenfolge festlegen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor(dat1$uni, levels = c(\"Uni Oldenburg\", \"Uni Bremen\", \"Uni Vechta\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Uni Bremen    Uni Vechta    Uni Oldenburg\nLevels: Uni Oldenburg Uni Bremen Uni Vechta\n```\n:::\n\n```{.r .cell-code}\ndat1$uni_fct <- factor(dat1$uni,\n                       levels = c(\"Uni Oldenburg\", \"Uni Bremen\", \"Uni Vechta\"))\n```\n:::\n\n\nWenn wir nun nach `uni_fct` sortieren, dann wird die Reihenfolge der `levels` berücksichtigt:\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(dat1$uni_fct)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"factor\"\n```\n:::\n\n```{.r .cell-code}\ndat1 %>% arrange(uni_fct)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni       uni_fct\n1 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n2 19173   322 1971 59.54348    Uni Bremen    Uni Bremen\n3  5333    67 1830 79.59701    Uni Vechta    Uni Vechta\n```\n:::\n:::\n\n\nMit `desc()` können wir in umgekehrter Reihenfolge sortieren:\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 %>% arrange(desc(uni_fct))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni       uni_fct\n1  5333    67 1830 79.59701    Uni Vechta    Uni Vechta\n2 19173   322 1971 59.54348    Uni Bremen    Uni Bremen\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n```\n:::\n:::\n\n\nDas mag für den Moment relativ trivial erscheinen, ist aber später sehr praktisch um in Grafiken Variablen in eine gewisse Ordnung zu bringen oder in Regressionsmodellen die Referenzkategorie festzulegen.\n\nNatürlich können wir auch nach mehreren Variablen sortieren, dazu fügen wir einfach weitere in `arrange()` ein:\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 %>% arrange(desc(uni_fct), gegr, studs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni       uni_fct\n1  5333    67 1830 79.59701    Uni Vechta    Uni Vechta\n2 19173   322 1971 59.54348    Uni Bremen    Uni Bremen\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n```\n:::\n:::\n\n(Macht in diesem Beispiel aber wenig Sinn)\n\n### [Übung](#data3) {#ue_3}\n\n## Projekt einrichten {#rproj}\n\nGrundsätzlich lohnt es sich, in RStudio Projekte einzurichten. \nProjekte sind `.Rproj`-Dateien ![](./pic/rproj-icon.png){width=\"30px\"}, die automatisch Arbeitsverzeichnis auf den Ort setzen, an dem sie gespeichert sind. \nDas erleichtert das kollaborative Arbeiten: egal wer und auf welchem Gerät gerade an einem Projekt arbeitet - durch die Projektdatei sind alle Pfade immer relativ zum Projektverzeichnis. Im weiteren können auch Versionkontrolle via git, bspw. [github](www.github.com) und weitere Funktionen in der Projektdatei hinterlegt werden und so für alle Nutzenden gleich gesetzt werden. \nAußerdem bleiben die zuletzt geöffneten Scripte geöffnet, was ein Arbeiten an mehreren Projekten erleichtert.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](./pic/102_Rproj.png){fig-align='center' width=65% height=55%}\n:::\n:::\n\n\nMit `getwd()` lässt sich überprüfen, ob das funktioniert hat:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetwd()\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"D:/Kurse/R-Kurs\"\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](./pic/102_Rproj2.png){fig-align='center' width=75% height=70%}\n:::\n:::\n\n\nAlternativ könnten wir auch mit folgendem Befehl ein .Rproj - Projekt erstellen (hier ein Beispiel für den [Aufruf eines Pakets mit `::`](#packages)):\n\n::: {.cell}\n\n```{.r .cell-code}\nrstudioapi::initializeProject(path = \"D:/Kurse/R-Kurs\")\n```\n:::\n\n\nSo können wir das Projekt dann öffnen:\n\n::: {.cell}\n\n```{.r .cell-code}\nrstudioapi::openProject(path = \"D:/Kurse/R-Kurs\")\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n## Datensätze einlesen {#import}\n\nIn der Regel werden wir aber Datensätze verwenden, deren Werte bereits in einer Datei gespeichert sind und die wir lediglich einlesen müssen. Dafür gibt es unzählige Möglichkeiten.\n\nIn diesem Seminar werden wir mit dem Campus-File des PASS arbeiten, dessen Teile als Stata-Dateien vorliegen.\n\nUm den Datensatz nun in R zu importieren, müssen wir R mitteilen unter welchem Dateipfad der Datensatz zu finden ist. Der Dateipfad ergibt sich aus der Ordnerstruktur Ihres Gerätes, so würde der Dateipfad im hier dargestellten Fall \"D:/Kurse/R-Kurs/\" lauten:\n\nNatürlich hängt der Dateipfad aber ganz davon ab, wo Sie den Datensatz gespeichert haben:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](./pic/102_dateipfad_datei.png){fig-align='center' width=45% height=45%}\n:::\n:::\n\n\nDiesen Dateipfad müssen wir also R mitteilen.\n\n\n### Der Einlesebefehl\n\nJetzt können wir den eigentlichen Einlesebefehl `read.table` verwenden. Für den Pfad können wir nach `file =` lediglich die Anführungszeichen angeben und innerhalb dieser die Tab-Taste drücken. Dann bekommen wir alle Unterverzeichnisse und Tabellen im Projektordner angezeigt.[^2]\n\n[^2]: Manchmal kann der Datensatz aber nicht im Unterordner des Projekts liegen, dann kann natürlich auch der gesamte Pfad in `read_dta()` angegeben werden: `pend <- read_dta(file = \"D:/Kurse/R-Kurs/data/PENDDAT_cf_W13.dta\")`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(haven)\npend <- read_dta(\"./orig/PENDDAT_cf_W13.dta\") \n```\n:::\n\n\nDer Einlesevorgang besteht aus zwei Teilen: zuerst geben wir mit `pend` den Objektnamen an, unter dem R den Datensatz ablegt. Nach dem `<-` steht dann der eigentliche Befehl `read_dta()`, der wiederum mehrere Optionen enthält. Als erstes geben wir den genauen Datensatznamen an - inklusive der Dateiendung. \n\n:::{.callout-important collapse=\"true\"}\n# R hat Probleme mit Windows-typischen `\\` in Datenpfaden\nLeider nutzen Windows-Systeme `\\` in den Dateipfaden - das führt in R zu Problemen. Daher müssen Dateipfade immer mit `/` oder alternativ mit `\\\\` angegeben werden. RStudio kann zumindest mit der *STRG + F*/der Suchen & Ersetzen Funktion etwas unterstützen.\n:::\n\nDas so erstellte Objekt ist ein `data.frame`:\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(pend)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n:::\n\n\nGenau genommen handelt es sich um ein `tibble` - das ist eine Weiterentwicklung von `data.frame`s im `tidyverse`, welcher u.a. Labels enthält und außerdem in der Darstellung einige zusätzliche Informationen enthält - in der ersten Zeile stehen bspw. die Variablenklassen.\n\n\nWürden hier jetzt einfach `pend` eintippen bekämen wir den kompletten Datensatz angezeigt. Für einen Überblick können wir `head` verwenden:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(pend)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 123\n         pnr      hnr welle   pintjahr pintmon pintmod  zpsex   palter PD0400   \n       <dbl>    <dbl> <dbl+l> <dbl+lb> <dbl+l> <dbl+lb> <dbl+l> <dbl+> <dbl+lbl>\n1 1000001901 10000019 1 [Wel… 2007     5 [Mai]  1 [CAP… 2 [Wei… 36       2 [Ehe…\n2 1000001902 10000019 1 [Wel… 2007     5 [Mai] NA       1 [Mae… 39       2 [Ehe…\n3 1000001901 10000019 3 [Wel… 2009     3 [Mae…  1 [CAP… 2 [Wei… 38      -9 [Ite…\n4 1000002001 10000020 1 [Wel… 2007     4 [Apr…  1 [CAP… 1 [Mae… 66     -10 [Ite…\n5 1000002002 10000020 1 [Wel… 2007     4 [Apr…  1 [CAP… 2 [Wei… 61       3 [Ehe…\n6 1000002002 10000020 2 [Wel… 2008     5 [Mai]  1 [CAP… 2 [Wei… 62       3 [Ehe…\n# ℹ 114 more variables: PA0100 <dbl+lbl>, PA0200 <dbl+lbl>, PA0300 <dbl+lbl>,\n#   PA0445 <dbl+lbl>, PA0800 <dbl+lbl>, PA0900 <dbl+lbl>, PA1000 <dbl+lbl>,\n#   PSM0100 <dbl+lbl>, PEO0100a <dbl+lbl>, PEO0100b <dbl+lbl>,\n#   PEO0100c <dbl+lbl>, PEO0100d <dbl+lbl>, PEO0100e <dbl+lbl>,\n#   PEO0200a <dbl+lbl>, PEO0200b <dbl+lbl>, PEO0200c <dbl+lbl>,\n#   PEO0200d <dbl+lbl>, PEO0300a <dbl+lbl>, PEO0300b <dbl+lbl>,\n#   PEO0300c <dbl+lbl>, PEO0300d <dbl+lbl>, PEO0300e <dbl+lbl>, …\n```\n:::\n:::\n\n\nMit `nrow` und `ncol` können wir kontrollieren, ob das geklappt hat. Der Datensatz sollte 28424 Zeilen und 123 Spalten haben:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(pend)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 28424\n```\n:::\n\n```{.r .cell-code}\nncol(pend)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 123\n```\n:::\n:::\n\n\nNatürlich können wir wie oben auch aus diesem, viel größeren, Datensatz Zeilen und Spalten auswählen. Zum Beispiel können wir die Daten aus dem Jahr 2006 auswählen und diese unter `pend06` ablegen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npend06 <- pend %>% filter(pintjahr == 2006)\n```\n:::\n\n\nAußerdem hat `pend06` natürlich deutlich weniger Zeilen als `pend`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(pend06)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 168\n```\n:::\n:::\n\n\nMöchten wir die genauen Altersangaben der Befragten aus `pend06` sehen, können wir die entsprechende Spalte mit `pend06$palter` aufrufen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npend06$palter\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<labelled<double>[168]>: Alter (Welle 1: gen. aus P1; ab Welle 2: beste Inf.), generiert\n  [1] 71 66 64 64 63 51 64 65 26 38 41 63 58 58 69 45 59 37 28 63 56 29 29 49 47\n [26] 66 34 22 21 37 36 58 56 80 44 65 61 66 40 53 34 70 69 54 65 62 58 54 51 57\n [51] 72 52 25 34 55 44 68 73 46 87 74 83 46 40 62 58 66 41 53 71 66 79 54 42 68\n [76] 68 81 92 70 66 68 77 44 66 66 67 62 43 35 35 52 54 20 48 48 20 41 24 22 33\n[101] 55 41 50 36 19 52 25 36 37 29 37 36 43 49 16 59 28 19 43 44 30 43 50 50 53\n[126] 52 71 43 58 58 58 38 49 30 27 50 58 26 36 44 28 19 42 44 23 20 33 24 31 32\n[151] 31 44 50 58 45 57 37 62 46 52 50 47 40 62 40 19 28 35\n\nLabels:\n value                                   label\n   -10 Item in Fragebogenversion nicht erhoben\n    -9             Item in Welle nicht erhoben\n    -8                       Unplausibler Wert\n    -4        Frage irrtuemlich nicht gestellt\n    -3                Trifft nicht zu (Filter)\n    -2                            Keine Angabe\n    -1                             Weiss nicht\n```\n:::\n:::\n\n\n\nWie wir beim Überblick gesehen haben, gibt es aber noch deutlich mehr Variablen im PASS als `palter` und nicht alle haben so aussagekräftige Namen - z.B. `PD0400`. Um diese Variablennamen und auch die Bedeutung der Ausprägungen zu verstehen brauchen wir das Codebuch.\nAußerdem können wir auf die `attributes()` einer Variable zurückgreifen - mehr zu labels später.\n\n### [Übung](#data4) {#ue_4}\n\n## Objekte exportieren\n\n::: callout-note\n#\n\nDer Begriff *speichern* kann in R bisweilen zu Missverständnissen führen: Ist gemeint, einen Datensatz o.ä. (1) auf der Festplatte als .csv, .dta, .sav für andere Programme zugänglich abzulegen oder (2) lediglich die Ergebnisse intern in R unter einem Objektnamen abzulegen? Ich vermeide daher das Wort speichern und spreche entweder von exportieren (Fall 1: in eine Datei schreiben) oder ablegen (Fall 2: Ergebnisse/Werte innerhalb von R in einem Objekt ablegen)\n:::\n\nWir können `data.frame`s exportieren und später wieder einlesen, das R-eigene Format dafür ist `.RData`:\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(pend06, file = \"./data/pend06.RData\")\nrm(pend06)\n\npend06_neu <- readRDS(file = \"./data/pend06.RData\")\nhead(pend06) # gibt es nicht mehr\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in head(pend06): Objekt 'pend06' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\nhead(pend06_neu) # das gibt es\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 123\n         pnr      hnr welle   pintjahr pintmon  pintmod zpsex   palter PD0400   \n       <dbl>    <dbl> <dbl+l> <dbl+lb> <dbl+lb> <dbl+l> <dbl+l> <dbl+> <dbl+lbl>\n1 1000402601 10004026 1 [Wel… 2006     12 [Dez… 0 [CAT… 1 [Mae… 71     -10 [Ite…\n2 1000402602 10004026 1 [Wel… 2006     12 [Dez… 0 [CAT… 2 [Wei… 66     -10 [Ite…\n3 1000409301 10004093 1 [Wel… 2006     12 [Dez… 0 [CAT… 2 [Wei… 64       3 [Ehe…\n4 1000421201 10004212 1 [Wel… 2006     12 [Dez… 0 [CAT… 1 [Mae… 64       3 [Ehe…\n5 1000421202 10004212 1 [Wel… 2006     12 [Dez… 0 [CAT… 2 [Wei… 63       1 [Ueb…\n6 1000426401 10004264 1 [Wel… 2006     12 [Dez… 0 [CAT… 1 [Mae… 51       1 [Ueb…\n# ℹ 114 more variables: PA0100 <dbl+lbl>, PA0200 <dbl+lbl>, PA0300 <dbl+lbl>,\n#   PA0445 <dbl+lbl>, PA0800 <dbl+lbl>, PA0900 <dbl+lbl>, PA1000 <dbl+lbl>,\n#   PSM0100 <dbl+lbl>, PEO0100a <dbl+lbl>, PEO0100b <dbl+lbl>,\n#   PEO0100c <dbl+lbl>, PEO0100d <dbl+lbl>, PEO0100e <dbl+lbl>,\n#   PEO0200a <dbl+lbl>, PEO0200b <dbl+lbl>, PEO0200c <dbl+lbl>,\n#   PEO0200d <dbl+lbl>, PEO0300a <dbl+lbl>, PEO0300b <dbl+lbl>,\n#   PEO0300c <dbl+lbl>, PEO0300d <dbl+lbl>, PEO0300e <dbl+lbl>, …\n```\n:::\n:::\n\n\nAuch andere Objekte können wir exportieren und dann wieder einlesen - hier wird aber der Objektname wiederhergestellt:\n\n::: {.cell}\n\n```{.r .cell-code}\nsave(studs, file = \"./data/stud_vektor.RData\")\nrm(studs)\nstuds\nload(file = \"./data/stud_vektor.RData\") # studs wieder mit selbem Namen zurück im environment\nstuds\n```\n:::\n\n\nDas funktioniert auch für mehrere Objekte:\n\n::: {.cell}\n\n```{.r .cell-code}\nsave(studs,profs, file = \"./data/meine_vektoren.RData\")\nrm(studs,profs)\nstuds\nprofs\nload(file = \"./data/meine_vektoren.RData\") # studs & profs mit selbem Namen zurück im environment\nstuds\nprofs\n```\n:::\n\n\n### [Übung](#data5) {#ue_5}\n\n\n## Überblick: Einlesen und Exportieren\n\n### Datensätze einlesen\n\n::: panel-tabset\n\n## Überblick\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table class=\" lightable-material table table-striped table-hover table-condensed\" style=\"font-family: Roboto; margin-left: auto; margin-right: auto; font-size: 12px; width: auto !important; margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Dateityp </th>\n   <th style=\"text-align:left;\"> R Funktion </th>\n   <th style=\"text-align:left;\"> R Paket </th>\n   <th style=\"text-align:left;\"> Anmerkung </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> .csv </td>\n   <td style=\"text-align:left;font-family: monospace;\"> read.table() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> - </td>\n   <td style=\"text-align:left;\"> mit `sep = \";\"` Trennzeichen angeben </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> .Rdata (R format) </td>\n   <td style=\"text-align:left;font-family: monospace;\"> readRDS </td>\n   <td style=\"text-align:left;font-family: monospace;\"> - </td>\n   <td style=\"text-align:left;\">  </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> große .csv </td>\n   <td style=\"text-align:left;font-family: monospace;\"> vroom() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> {vroom} </td>\n   <td style=\"text-align:left;\"> mit `delim = \";\"` Trennzeichen angeben </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> .dta (Stata) </td>\n   <td style=\"text-align:left;font-family: monospace;\"> read_dta() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> {haven} </td>\n   <td style=\"text-align:left;\">  </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> .dta (Stata - große Dateien) </td>\n   <td style=\"text-align:left;font-family: monospace;\"> read.dta13() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> {readstata13} </td>\n   <td style=\"text-align:left;\"> mit convert.factors = F nur Zahlenwerte einlesen <br> liest auch neuere Stata-Dateien ein </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> .dat (SPSS) </td>\n   <td style=\"text-align:left;font-family: monospace;\"> read_spss() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> {haven} </td>\n   <td style=\"text-align:left;\">  </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> .xlsx (Excel) </td>\n   <td style=\"text-align:left;font-family: monospace;\"> read_xlsx() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> {readxl} </td>\n   <td style=\"text-align:left;\"> mit `sheet = 1` Tabellenblatt angeben (funktioniert auch mit Namen) </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## Code\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# csv Datei\ndat1 <- read.table(file = \"Dateiname.csv\",sep = \";\")\n\n# Rdata\ndat1 <- readRDS(file = \"Dateiname.Rdata\")\n\n# große csv\nlibrary(vroom)\ndat1 <- vroom(file = \"Dateiname.csv\",delim = \";\")\n\n# Stata dta\nlibrary(haven)\ndat1 <- read_dta(file = \"Dateiname.dta\")\n\n# Stata große Dateien\n# deutlich schneller als mit haven, aber data.frame hat dann keine Labels\nlibrary(readstata13)\ndat1 <- read.dta13(file = \"Dateiname.dta\",convert.factors = F) \n\n# SPSS sav\ndat1 <- read_sav(file = \"Dateiname.sav\")\n\n# Excel\ndat1 <- read_xlsx(path = \"Dateiname.xlsx\", sheet = \"1\")\ndat1 <- read_xlsx(path = \"Dateiname.xlsx\", sheet = \"Tabellenblatt1\")\n```\n:::\n\n:::\n\n### Datensätze exportieren\n\n::: panel-tabset\n## Überblick\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table class=\" lightable-material table table-striped table-hover table-condensed\" style=\"font-family: Roboto; margin-left: auto; margin-right: auto; font-size: 12px; width: auto !important; margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Dateityp </th>\n   <th style=\"text-align:left;\"> R Funktion </th>\n   <th style=\"text-align:left;\"> R Paket </th>\n   <th style=\"text-align:left;\"> Anmerkung </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> .Rdata (R format) </td>\n   <td style=\"text-align:left;font-family: monospace;\"> saveRDS() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> - </td>\n   <td style=\"text-align:left;\"> alle Variableneigenschaften bleiben erhalten </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> .csv </td>\n   <td style=\"text-align:left;font-family: monospace;\"> write.table() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> - </td>\n   <td style=\"text-align:left;\"> mit `sep = \";\"` Trennzeichen angeben<br>mit row.names= F Zeilennummerierung unterdrücken </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> .dta (Stata) </td>\n   <td style=\"text-align:left;font-family: monospace;\"> write_dta() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> {haven} </td>\n   <td style=\"text-align:left;\">  </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> .dat (SPSS) </td>\n   <td style=\"text-align:left;font-family: monospace;\"> write_spss() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> {haven} </td>\n   <td style=\"text-align:left;\">  </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> .xlsx (Excel) </td>\n   <td style=\"text-align:left;font-family: monospace;\"> write.xlsx() </td>\n   <td style=\"text-align:left;font-family: monospace;\"> {xlsx} </td>\n   <td style=\"text-align:left;\"> mit `sheetName` ggf. Tabellenblattname angeben </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Rdata\nsaveRDS(dat1,file = \"Dateiname.Rdata\")\n# csv\nwrite.table(dat1,file = \"Dateiname.csv\",sep = \";\",row.names = F)\n# dta\nlibrary(haven)\nwrite_dta(dat1,path = \"Dateiname.dta\")\n# sav\nlibrary(haven)\nwrite_sav(dat1,path = \"Dateiname.sav\")\n# xlsx\nlibrary(xlsx)\nwrite.xlsx(dat1,file = \"Dateiname.xlsx\", sheetName = \"Tabellenblatt 1\")\n```\n:::\n\n:::\n\n\n\n## Hilfe zu Paketen und Funktionen\n\nR Pakete kommen (häufig) mit sehr ausführlichen Hilfeseiten, die entweder direkt aus RStudio abgerufen werden können:\n\n::: {.cell}\n\n```{.r .cell-code}\n# Hilfe zu Paketen\nvignette(\"dplyr\")\nvignette(package = \"dplyr\")\nvignette(\"rowwise\")\nhelp(\"dplyr\")\nhelp(package = \"dplyr\")\n\n\n# Hilfe zu Funktionen\n?select()\n```\n:::\n\n\nAlternativ führt aber Google auch zum Ziel, bspw. [**R dplyr select()**](https://www.google.de/search?q=R+dplyr+select())\n\nOder auf CRAN (woher auch `install.packages()` die Pakete bezieht):\n\n::: {.cell}\n::: {.cell-output-display}\n![[CRAN-Seite für {dplyr}](https://cran.r-project.org/web/packages/dplyr/index.html)](./pic/102_dplyr_vignette.png){width=488 height=30%}\n:::\n:::\n\n\n\n## Übungen\n### Übung 1 {#data1}\n\n-   Erstellen Sie den Datensatz mit den Studierenden- & Prof-Zahlen wie gezeigt:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2 <- data.frame(studs = c(14954,47269 ,23659,9415 ,38079), \n                   profs = c(250,553,438 ,150,636),\n                   prom_recht = c(FALSE,TRUE,TRUE,TRUE,FALSE),\n                   gegr  = c(1971,1870,1457,1818,1995))\n```\n:::\n\n\n\n\n-   Sehen Sie den `dat2` in Ihrem Environment?\n-   Lassen Sie sich `dat2` in der Console ausgeben.\n-   Fügen Sie die Namen der Unis als neue Spalte in den Datensatz ein. Diese sind in dieser Reihenfolge:\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"FH Aachen\",\"RWTH Aachen\",\"Uni Freiburg\",\"Uni Bonn\",\"FH Bonn-Rhein-Sieg\")\n```\n:::\n\n\n-  Lassen Sie sich `dat2` anzeigen - in der Console oder mit `View()`\n-  Berechnen Sie das Verhältnis Studierende pro Professur und legen Sie die Ergebnisse in einer neuen Variable an. Sehen Sie sich das Ergebnis an.\n-  Lassen Sie sich nur die dritte Zeile von `dat2` anzeigen.\n-  Lassen Sie sich nur die dritte Spalte von `dat2` anzeigen.\n-  Lassen Sie sich nur die Unis mit unter 10000 Studierenden anzeigen.\n\n[Zurück nach oben](#ue_1)\n\n### Übung 2 {#data2}\n\n-   [Legen Sie `.Rprofile` für die Paketinstalltion](#fdz_install) in `C:\\Users\\*KENNUNG*\\Documents`\n-   Installieren Sie die Pakete des tidyverse mit `fdz_install(\"tidyverse\")`, nachdem Sie die `.Rprofile`-Datei in unter **PFAD** abgelegt haben.\n-   Verwenden Sie wieder den `data.frame` `dat2` aus Übung 1\n-   Nutzen Sie `filter`, um sich nur die Unis mit unter 10000 Studierenden anzeigen zu lassen. (Denken Sie daran, `{tidyverse}` zu installieren und mit `library()` zu laden)\n-   Lassen Sie sich nur die Spalte `gegr` anzeigen.\n-   Lassen Sie sich nur Zeilen der Hochschulen mit Promotionsrecht (`prom_recht`) anzeigen.\n\n[Zurück nach oben](#ue_2)\n\n\n### Übung 3 {#data3}\n\n-   Verwenden Sie weiterhin den Datensatz aus Übung 1 & 2.\n-   Lassen Sie sich nur Hochschulen anzeigen, die 1971, 1457 oder 1995 gegründet wurden - und für diese Fälle nur den Namen und das Gründungsjahr.\n-   Sortieren Sie den Datensatz entsprechend dieser Reihenfolge. (Legen Sie dazu eine `factor`-Variable an, welche die entsprechende Reihenfolge festlegt.)\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"RWTH Aachen\",\"Uni Freiburg\",\"Uni Bonn\",\"FH Aachen\",\"FH Bonn-Rhein-Sieg\")\n```\n:::\n\n\n[Zurück nach oben](#ue_3)\n\n\n\n### Übung 4 {#data4}\n\n-   Erstellen Sie in Ihrem Verzeichnis für diesen Kurs ein [R-Projekt](#rproj)\n-   Speichern Sie die Personendaten des PASS-CampusFile (PENDDAT_cf_W13.dta) in Ihrem Verzeichnis im Unterordner *orig*.\n-   Lesen Sie den Datensatz `PENDDAT_cf_W13.dta` [wie oben gezeigt](#import) in R ein und legen Sie den Datensatz unter dem Objektnamen `pend` ab.\n-   Nutzen Sie `head()` und `View()`, um sich einen Überblick über den Datensatz zu verschaffen.\n-   Wie viele Befragte (Zeilen) enthält der Datensatz?\n-   Lassen Sie sich die Variablennamen von `pend` mit `names()` anzeigen!\n-   Wie können Sie sich die Zeilen anzeigen lassen, welche den/die Befragte\\*n mit der `pnr` 1000908201 enthält?\n-   Wählen Sie alle Befragten aus, die älter als 60 (Alter: `palter`) sind legen Sie diese Auswahl unter `ue_1960` ab.\n-   Wie müssen Sie den Befehl anpassen, sodass `ue_1960` nur die Variablen `pnr`, `hnr`, `welle`, `pintjahr` und `palter` enthält?\n-   Wie viele Spalten hat `ue_1960`? Wie viele Zeilen?\n\n**Bonusübungen**: \n\n>  - Wie alt ist der/die Befragte mit der `pnr` 1000908201 in `welle` 10 (im `pintjahr` 2016)?\n>  - Erstellen Sie eine neue Variable mit dem Geburtsjahr der Befragten (basierend auf dem Alter `palter` und dem Interviewjahr `pintjahr`).\n    \n[Zurück nach oben](#ue_4)\n\n### Übung 5 {#data5}\n\n-  Exportieren Sie den `data.frame` mit den in der vorherigen Übung erstellten kleineren Datensatz-Version (`ue_1960`) als `.Rdata`-Datei.\n-  Laden Sie die eben exportierte `.Rdata`-Datei unter einem beliebigen Namen, bspw. `ue_1960_neu`. \n-  Hat alles geklappt? Vergleichen Sie das neu geladene mit dem ursprünglichen Objekt: `identical(ue_1960,ue_1960_neu)` - sind beide Objekte identisch?\n\n[Zurück nach oben](#ue_5)\n\n\n## Anhang\n\n### Alternativen zu R-Projekten {#setwd}\n\nNeben dem Einrichten eines Projekts können wir den Pfad auch mit `setwd()` setzen oder direkt in `read_dta()` bzw. anderen `read...()`-Befehlen angeben. Das hat allerdings den Nachteil, dass diese Strategie nicht auf andere Rechner übertragbar ist: wenn jemand anderes die `.Rproj`-Datei öffnet, wird R automatisch die Pfade relativ zum Speicherort der Datei setzen. Das gilt auch wenn wir das Verzeichnis verschieben auf unserem Gerät - R wird automatisch das Arbeitsverzeichnis auf den neuen Speicherort setzen.\n\nZum Setzen des Arbeitsverzeichnis mit `setwd()` setzen wir in die Klammern den Pfad des Ordners ein. Wichtig dabei ist dass Sie ggf. alle `\\` durch `/`ersetzen müssen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetwd(\"D:/Kurse/R_IAB\")\n```\n:::\n\n\nMit `getwd()` lässt sich überprüfen, ob das funktioniert hat:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetwd()\n```\n:::\n\n\nHier sollte der mit `setwd()` gesetzte Pfad erscheinen.\n\nAlternativ können wir auch in `read_dta()` den vollen Pfad angeben:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npend <- haven::read_dta(\"C:/Kurse/R_IAB/orig/PENDDAT_cf_W13.dta\")\n```\n:::\n\n\n### Zeilen & Spaltenauswahl ohne `{dplyr}` {#selfiltbase}\n\nNatürlich kann auch base R (also R ohne Erweiterungen wie `{dplyr}` Datensätze filtern usw.), dazu wird  \\[ \\] verwendet:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1[1,1] # erste Zeile, erste Spalte\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19173\n```\n:::\n\n```{.r .cell-code}\ndat1[1,]  # erste Zeile, alle Spalten\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof        uni    uni_fct\n1 19173   322 1971 59.54348 Uni Bremen Uni Bremen\n```\n:::\n\n```{.r .cell-code}\ndat1[,1]  # alle Zeilen, erste Spalte (entspricht hier dat1$studs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19173  5333 15643\n```\n:::\n\n```{.r .cell-code}\ndat1[,\"studs\"] # alle Zeilen, Spalte mit Namen studs -> achtung: \"\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19173  5333 15643\n```\n:::\n:::\n\n\nNatürlich können wir auch mehrere Zeilen oder Spalten auswählen. Dafür müssen wir wieder auf `c( )` zurückgreifen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1[c(1,2),]  ## 1. & 2. Zeile, alle Spalten\ndat1[,c(1,3)]  ## alle Zeilen, 1. & 3. Spalte (entspricht dat1$studs & dat1$stu_prof)\ndat1[,c(\"studs\",\"uni\")] ## alle Zeilen, Spalten mit Namen studs und uni\n```\n:::\n\n\nIn diese eckigen Klammern können wir auch Bedingungen schreiben, um so Auswahlen aus `dat1` zu treffen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 # vollständiger Datensatz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni       uni_fct\n1 19173   322 1971 59.54348    Uni Bremen    Uni Bremen\n2  5333    67 1830 79.59701    Uni Vechta    Uni Vechta\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n```\n:::\n\n```{.r .cell-code}\ndat1[dat1$uni == \"Uni Oldenburg\", ] # Zeilen in denen uni gleich \"Uni Oldenburg\", alle Spalten\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs profs gegr stu_prof           uni       uni_fct\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n```\n:::\n\n```{.r .cell-code}\ndat1$studs[dat1$uni == \"Uni Oldenburg\" ] # Nur Studi-Zahl nachsehen: kein Komma \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15643\n```\n:::\n:::\n\n\nDas funktioniert soweit wie gewünscht und wir können das Ganze jetzt erweitern:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1[dat1$uni == \"Uni Oldenburg\" & dat1$studs > 10000, ] # & bedeutet UND\n```\n:::\n\n\nWir können auch hier einen ODER-Operator verwenden:\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1[dat1$uni == \"Uni Oldenburg\" | dat1$studs > 10000, ]\n```\n:::\n\n\n\n### `select()` vs `$`\n\n \nWenn wir mit `select()` eine spezifische Variable auswählen, wird trotzdem die Datenstruktur als `data.frame()` erhalten, während die Auswahl `dat1$variablenname` die Spalte als Vektor (also Wertereihe) ausgibt:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1$studs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19173  5333 15643\n```\n:::\n\n```{.r .cell-code}\nclass(dat1$studs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\ndat1$studs/ 20\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 958.65 266.65 782.15\n```\n:::\n:::\n\n\n`select()` erhält die Werte als Spalte eines `data.frame`:\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 %>% select(studs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  studs\n1 19173\n2  5333\n3 15643\n```\n:::\n\n```{.r .cell-code}\ndat1 %>% select(studs) %>% class()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\ndat1 %>% select(studs)/20 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   studs\n1 958.65\n2 266.65\n3 782.15\n```\n:::\n:::\n",
    "supporting": [
      "02_intro_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\r\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}